import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.5916b37e.js";const g=JSON.parse('{"title":"Segmentation Module Documentation","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/segmentation-module.md","filePath":"zh/guide/segmentation-module.md"}'),o={name:"zh/guide/segmentation-module.md"},l=e(`<h1 id="segmentation-module-documentation" tabindex="-1">Segmentation Module Documentation <a class="header-anchor" href="#segmentation-module-documentation" aria-label="Permalink to &quot;Segmentation Module Documentation&quot;">​</a></h1><blockquote><p>Source: <code>annotator-frontend/src/ts/Utils/segmentation/</code></p></blockquote><blockquote><p>⚠️ <strong>注意</strong>：文档中所有行号引用均来自历史版本，经过多轮重构（State Management Refactor + NrrdTools God Class Split + 继承→组合重构）后已过时，仅作结构参考，请以实际代码为准。</p></blockquote><h2 id="_1-architecture-overview" tabindex="-1">1. Architecture Overview <a class="header-anchor" href="#_1-architecture-overview" aria-label="Permalink to &quot;1. Architecture Overview&quot;">​</a></h2><h3 id="_1-1-class-composition-组合模式" tabindex="-1">1.1 Class Composition（组合模式） <a class="header-anchor" href="#_1-1-class-composition-组合模式" aria-label="Permalink to &quot;1.1 Class Composition（组合模式）&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">NrrdTools (Facade)</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├── CanvasState              ← 纯状态容器（nrrd_states, gui_states, protectedData 等）</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├── DrawToolCore             ← 事件编排、Undo/Redo、Tool 初始化与委托</span></span>
<span class="line"><span style="color:#e1e4e8;">  │     ├── CanvasState (共享)  ← 引用同一 CanvasState 实例</span></span>
<span class="line"><span style="color:#e1e4e8;">  │     └── RenderingUtils     ← 渲染/切片缓冲区工具</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├── LayerChannelManager      ← 图层/通道/SphereType 管理（211 行）</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├── SliceRenderPipeline      ← 切片渲染管线（453 行）</span></span>
<span class="line"><span style="color:#e1e4e8;">  └── DataLoader               ← 数据加载（222 行）</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">NrrdTools (Facade)</span></span>
<span class="line"><span style="color:#24292e;">  ├── CanvasState              ← 纯状态容器（nrrd_states, gui_states, protectedData 等）</span></span>
<span class="line"><span style="color:#24292e;">  ├── DrawToolCore             ← 事件编排、Undo/Redo、Tool 初始化与委托</span></span>
<span class="line"><span style="color:#24292e;">  │     ├── CanvasState (共享)  ← 引用同一 CanvasState 实例</span></span>
<span class="line"><span style="color:#24292e;">  │     └── RenderingUtils     ← 渲染/切片缓冲区工具</span></span>
<span class="line"><span style="color:#24292e;">  ├── LayerChannelManager      ← 图层/通道/SphereType 管理（211 行）</span></span>
<span class="line"><span style="color:#24292e;">  ├── SliceRenderPipeline      ← 切片渲染管线（453 行）</span></span>
<span class="line"><span style="color:#24292e;">  └── DataLoader               ← 数据加载（222 行）</span></span></code></pre></div><blockquote><p><strong>继承→组合重构（已完成）</strong>: 原先的三级继承链 <code>NrrdTools → DrawToolCore → CommToolsData</code> 已完全替换为组合关系。<code>CommToolsData</code> 已删除。状态提取到 <code>CanvasState</code>，渲染方法提取到 <code>RenderingUtils</code>。</p><p><strong>DrawToolCore</strong> 现在是纯编排层 — 所有工具逻辑已提取到各 Tool 类中。 DrawToolCore 通过 EventRouter 永久路由所有 pointer/wheel 事件，并在 <code>start()</code> render loop 中调度各 Tool 的渲染方法。 不再有手动 <code>addEventListener</code>/<code>removeEventListener</code> 调用（wheel 行为通过 <code>activeWheelMode</code> 状态派发）。</p><p><strong>NrrdTools God Class Split（已完成）</strong>: NrrdTools 经过 4 个 Phase 的重构，从 2007 行 God Class 拆分为 Facade + 3 个功能模块。公开 API 不变，内部通过 <code>ToolContext</code> + <code>ToolHost</code> <code>Pick&lt;&gt;</code> 类型解耦。</p><p><strong>Callback 接口统一（已完成）</strong>: 原先 10 个 <code>*Callbacks</code> 接口已统一为单一 <code>ToolHost</code> 接口（<code>tools/ToolHost.ts</code>），每个 Tool 通过 <code>Pick&lt;ToolHost, ...&gt;</code> 选择所需的宿主方法子集。</p></blockquote><ul><li><a href="annotator-frontend/src/ts/Utils/segmentation/CanvasState.ts">CanvasState.ts</a> — 纯状态容器</li><li><a href="annotator-frontend/src/ts/Utils/segmentation/RenderingUtils.ts">RenderingUtils.ts</a> — 渲染工具</li><li><a href="annotator-frontend/src/ts/Utils/segmentation/DrawToolCore.ts">DrawToolCore.ts</a> — 绘画核心（组合 CanvasState + RenderingUtils）</li><li><a href="annotator-frontend/src/ts/Utils/segmentation/NrrdTools.ts">NrrdTools.ts</a> — 对外 API Facade（组合 CanvasState + DrawToolCore）</li><li><a href="annotator-frontend/src/ts/Utils/segmentation/tools/LayerChannelManager.ts">tools/LayerChannelManager.ts</a> — 图层/通道管理</li><li><a href="annotator-frontend/src/ts/Utils/segmentation/tools/SliceRenderPipeline.ts">tools/SliceRenderPipeline.ts</a> — 切片渲染管线</li><li><a href="annotator-frontend/src/ts/Utils/segmentation/tools/DataLoader.ts">tools/DataLoader.ts</a> — 数据加载</li></ul><h3 id="_1-2-canvas-层级结构" tabindex="-1">1.2 Canvas 层级结构 <a class="header-anchor" href="#_1-2-canvas-层级结构" aria-label="Permalink to &quot;1.2 Canvas 层级结构&quot;">​</a></h3><p>共有 <strong>5 个系统 Canvas</strong> + <strong>N 个 Layer Canvas</strong>（默认 3 个 Layer）。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">┌──────────────────────────────────┐</span></span>
<span class="line"><span style="color:#e1e4e8;">│ drawingCanvas (顶层交互层)         │  ← 捕获鼠标/笔事件，实时绘制笔画</span></span>
<span class="line"><span style="color:#e1e4e8;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#e1e4e8;">│ drawingSphereCanvas              │  ← 3D Sphere 工具的覆盖层</span></span>
<span class="line"><span style="color:#e1e4e8;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#e1e4e8;">│ drawingCanvasLayerMaster (合成层)  │  ← 所有可见 Layer 合成后的结果</span></span>
<span class="line"><span style="color:#e1e4e8;">│   ├─ layerTargets[layer1].canvas │  ← 隐藏的 per-layer canvas</span></span>
<span class="line"><span style="color:#e1e4e8;">│   ├─ layerTargets[layer2].canvas │</span></span>
<span class="line"><span style="color:#e1e4e8;">│   └─ layerTargets[layer3].canvas │</span></span>
<span class="line"><span style="color:#e1e4e8;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#e1e4e8;">│ displayCanvas (背景医学图像)       │  ← CT/MRI 切片图像</span></span>
<span class="line"><span style="color:#e1e4e8;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#e1e4e8;">│ originCanvas (从 Three.js 获取)   │  ← 缓存 Three.js 渲染的原始切片</span></span>
<span class="line"><span style="color:#e1e4e8;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#e1e4e8;">│ emptyCanvas (临时处理用)           │  ← 离屏画布，用于图像处理和格式转换</span></span>
<span class="line"><span style="color:#e1e4e8;">└──────────────────────────────────┘</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">┌──────────────────────────────────┐</span></span>
<span class="line"><span style="color:#24292e;">│ drawingCanvas (顶层交互层)         │  ← 捕获鼠标/笔事件，实时绘制笔画</span></span>
<span class="line"><span style="color:#24292e;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#24292e;">│ drawingSphereCanvas              │  ← 3D Sphere 工具的覆盖层</span></span>
<span class="line"><span style="color:#24292e;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#24292e;">│ drawingCanvasLayerMaster (合成层)  │  ← 所有可见 Layer 合成后的结果</span></span>
<span class="line"><span style="color:#24292e;">│   ├─ layerTargets[layer1].canvas │  ← 隐藏的 per-layer canvas</span></span>
<span class="line"><span style="color:#24292e;">│   ├─ layerTargets[layer2].canvas │</span></span>
<span class="line"><span style="color:#24292e;">│   └─ layerTargets[layer3].canvas │</span></span>
<span class="line"><span style="color:#24292e;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#24292e;">│ displayCanvas (背景医学图像)       │  ← CT/MRI 切片图像</span></span>
<span class="line"><span style="color:#24292e;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#24292e;">│ originCanvas (从 Three.js 获取)   │  ← 缓存 Three.js 渲染的原始切片</span></span>
<span class="line"><span style="color:#24292e;">├──────────────────────────────────┤</span></span>
<span class="line"><span style="color:#24292e;">│ emptyCanvas (临时处理用)           │  ← 离屏画布，用于图像处理和格式转换</span></span>
<span class="line"><span style="color:#24292e;">└──────────────────────────────────┘</span></span></code></pre></div><p><strong>Canvas 创建位置:</strong></p><ul><li>系统 Canvas: <a href="annotator-frontend/src/ts/Utils/segmentation/CanvasState.ts">CanvasState.ts</a> <code>generateSystemCanvases()</code></li><li>Layer Canvas: <a href="annotator-frontend/src/ts/Utils/segmentation/CanvasState.ts">CanvasState.ts</a> <code>generateLayerTargets(layerIds)</code></li><li>Canvas 注释说明: <a href="annotator-frontend/src/ts/Utils/segmentation/CanvasState.ts">CanvasState.ts</a> constructor</li></ul><h3 id="_1-3-nrrdtools-facade-内部模块" tabindex="-1">1.3 NrrdTools Facade 内部模块 <a class="header-anchor" href="#_1-3-nrrdtools-facade-内部模块" aria-label="Permalink to &quot;1.3 NrrdTools Facade 内部模块&quot;">​</a></h3><p>NrrdTools 通过 <code>ToolContext</code> 将共享状态传递给各模块，通过 <code>Pick&lt;ToolHost, ...&gt;</code> 类型别名声明宿主方法依赖：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ToolContext = {</span></span>
<span class="line"><span style="color:#e1e4e8;">  nrrd_states: NrrdState,</span></span>
<span class="line"><span style="color:#e1e4e8;">  gui_states: GuiState,</span></span>
<span class="line"><span style="color:#e1e4e8;">  protectedData: IProtected,</span></span>
<span class="line"><span style="color:#e1e4e8;">  cursorPage: ICursorPage,</span></span>
<span class="line"><span style="color:#e1e4e8;">  callbacks: IAnnotationCallbacks,</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ToolContext = {</span></span>
<span class="line"><span style="color:#24292e;">  nrrd_states: NrrdState,</span></span>
<span class="line"><span style="color:#24292e;">  gui_states: GuiState,</span></span>
<span class="line"><span style="color:#24292e;">  protectedData: IProtected,</span></span>
<span class="line"><span style="color:#24292e;">  cursorPage: ICursorPage,</span></span>
<span class="line"><span style="color:#24292e;">  callbacks: IAnnotationCallbacks,</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><table><thead><tr><th>模块</th><th>文件</th><th>职责</th><th>HostDeps 类型</th></tr></thead><tbody><tr><td><strong>LayerChannelManager</strong></td><td><code>tools/LayerChannelManager.ts</code></td><td>setActiveLayer/Channel/SphereType、可见性控制、自定义通道颜色</td><td><code>LayerChannelHostDeps</code> (3 methods)</td></tr><tr><td><strong>SliceRenderPipeline</strong></td><td><code>tools/SliceRenderPipeline.ts</code></td><td>切片轴配置、canvas 渲染、mask 重载、canvas 翻转、view/canvas 辅助</td><td><code>SliceRenderHostDeps</code> (10 methods)</td></tr><tr><td><strong>DataLoader</strong></td><td><code>tools/DataLoader.ts</code></td><td>NRRD 切片加载、legacy mask 加载、NIfTI voxel 加载</td><td><code>DataLoaderHostDeps</code> (7 methods)</td></tr></tbody></table><p>NrrdTools 中的委托方法均为一行调用 (<code>this.layerChannelManager.xxx()</code>)，不包含任何业务逻辑。</p><h3 id="_1-4-layer-与-maskvolume-对应关系" tabindex="-1">1.4 Layer 与 MaskVolume 对应关系 <a class="header-anchor" href="#_1-4-layer-与-maskvolume-对应关系" aria-label="Permalink to &quot;1.4 Layer 与 MaskVolume 对应关系&quot;">​</a></h3><p>每个 Layer 对应一个独立的 <code>MaskVolume</code> 实例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">protectedData.maskData.volumes = {</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;layer1&quot;: MaskVolume(width, height, depth, 1),</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;layer2&quot;: MaskVolume(width, height, depth, 1),</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;layer3&quot;: MaskVolume(width, height, depth, 1),</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">protectedData.maskData.volumes = {</span></span>
<span class="line"><span style="color:#24292e;">  &quot;layer1&quot;: MaskVolume(width, height, depth, 1),</span></span>
<span class="line"><span style="color:#24292e;">  &quot;layer2&quot;: MaskVolume(width, height, depth, 1),</span></span>
<span class="line"><span style="color:#24292e;">  &quot;layer3&quot;: MaskVolume(width, height, depth, 1),</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><ul><li>初始化（1x1x1 占位）: <a href="annotator-frontend/src/ts/Utils/segmentation/CanvasState.ts">CanvasState.ts</a> constructor</li><li>用实际 NRRD 尺寸重新初始化: <code>DataLoader.setAllSlices()</code> → <code>tools/DataLoader.ts</code>（已从 NrrdTools 提取）</li></ul><hr><h2 id="_2-nrrdtools-暴露的-api" tabindex="-1">2. NrrdTools 暴露的 API <a class="header-anchor" href="#_2-nrrdtools-暴露的-api" aria-label="Permalink to &quot;2. NrrdTools 暴露的 API&quot;">​</a></h2><blockquote><p>⚠️ <strong>行号均已过时</strong>。NrrdTools 经过 God Class Split 重构后（1300 行，13 个分区），方法实现已迁移到各提取模块（LayerChannelManager、SliceRenderPipeline、DataLoader），NrrdTools 中仅保留一行委托。行号仅供历史参考，请以实际代码为准。</p><p>实现位置：Layer/Channel 方法 → <code>tools/LayerChannelManager.ts</code>，渲染方法 → <code>tools/SliceRenderPipeline.ts</code>，数据加载 → <code>tools/DataLoader.ts</code>。</p></blockquote><h3 id="_2-1-layer-channel-管理" tabindex="-1">2.1 Layer &amp; Channel 管理 <a class="header-anchor" href="#_2-1-layer-channel-管理" aria-label="Permalink to &quot;2.1 Layer &amp; Channel 管理&quot;">​</a></h3><blockquote><p><strong>实现</strong>: <code>tools/LayerChannelManager.ts</code>，NrrdTools 中一行委托。</p></blockquote><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>setActiveLayer</code></td><td><code>(layerId: string): void</code></td><td>设置当前活跃 Layer，同时更新 fillColor/brushColor</td></tr><tr><td><code>setActiveChannel</code></td><td><code>(channel: ChannelValue): void</code></td><td>设置当前活跃 Channel (1-8)，更新画笔颜色</td></tr><tr><td><code>getActiveLayer</code></td><td><code>(): string</code></td><td>获取当前 Layer ID</td></tr><tr><td><code>getActiveChannel</code></td><td><code>(): number</code></td><td>获取当前 Channel 值</td></tr><tr><td><code>setLayerVisible</code></td><td><code>(layerId, visible): void</code></td><td>设置 Layer 可见性，触发 <code>reloadMasksFromVolume()</code></td></tr><tr><td><code>isLayerVisible</code></td><td><code>(layerId): boolean</code></td><td>检查 Layer 是否可见</td></tr><tr><td><code>setChannelVisible</code></td><td><code>(layerId, channel, visible): void</code></td><td>设置某 Layer 下某 Channel 可见性，触发重渲染</td></tr><tr><td><code>isChannelVisible</code></td><td><code>(layerId, channel): boolean</code></td><td>检查 Channel 是否可见</td></tr><tr><td><code>getLayerVisibility</code></td><td><code>(): Record&lt;string, boolean&gt;</code></td><td>获取所有 Layer 可见性副本</td></tr><tr><td><code>getChannelVisibility</code></td><td><code>(): Record&lt;string, Record&lt;number, boolean&gt;&gt;</code></td><td>获取所有 Channel 可见性副本</td></tr><tr><td><code>hasLayerData</code></td><td><code>(layerId): boolean</code></td><td>检查 Layer 是否有非零数据</td></tr></tbody></table><h3 id="_2-2-custom-channel-color-api-phase-b" tabindex="-1">2.2 Custom Channel Color API（Phase B） <a class="header-anchor" href="#_2-2-custom-channel-color-api-phase-b" aria-label="Permalink to &quot;2.2 Custom Channel Color API（Phase B）&quot;">​</a></h3><p>Per-layer 自定义 channel 颜色。每个 layer 的 MaskVolume 有独立的 <code>colorMap</code>，互不影响。</p><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>setChannelColor</code></td><td><code>(layerId: string, channel: number, color: RGBAColor): void</code></td><td>设置指定 layer 指定 channel 的颜色，触发重渲染和 <code>onChannelColorChanged</code> 回调</td></tr><tr><td><code>getChannelColor</code></td><td><code>(layerId: string, channel: number): RGBAColor</code></td><td>获取 RGBA 颜色对象</td></tr><tr><td><code>getChannelHexColor</code></td><td><code>(layerId: string, channel: number): string</code></td><td>获取 Hex 字符串（如 <code>#ff8000</code>）</td></tr><tr><td><code>getChannelCssColor</code></td><td><code>(layerId: string, channel: number): string</code></td><td>获取 CSS rgba() 字符串（如 <code>rgba(255,128,0,1.00)</code>）</td></tr><tr><td><code>setChannelColors</code></td><td><code>(layerId: string, colorMap: Partial&lt;ChannelColorMap&gt;): void</code></td><td>批量设置一个 layer 的多个 channel 颜色（一次 reload）</td></tr><tr><td><code>setAllLayersChannelColor</code></td><td><code>(channel: number, color: RGBAColor): void</code></td><td>所有 layer 的同一 channel 设为相同颜色</td></tr><tr><td><code>resetChannelColors</code></td><td><code>(layerId?: string, channel?: number): void</code></td><td>重置为 <code>MASK_CHANNEL_COLORS</code> 默认颜色</td></tr></tbody></table><p><strong>内部机制</strong>:</p><ul><li><code>syncBrushColor()</code> — 私有方法，从当前 layer 的 volume 动态获取颜色更新 <code>fillColor</code>/<code>brushColor</code></li><li>在 <code>setActiveLayer()</code>、<code>setActiveChannel()</code>、<code>setChannelColor()</code> 等方法中自动调用</li></ul><h4 id="外部使用方式" tabindex="-1">外部使用方式 <a class="header-anchor" href="#外部使用方式" aria-label="Permalink to &quot;外部使用方式&quot;">​</a></h4><p><strong>前提</strong>: <code>nrrdTools</code> 实例已创建，且 <code>setAllSlices()</code> 已调用完毕（即图像已加载，MaskVolume 已初始化）。</p><blockquote><p>⚠️ <strong>重要</strong>: 必须在图像加载完成（<code>setAllSlices()</code> 调用后）才能设置颜色，否则 MaskVolume 尚未创建，调用会静默失败（<code>console.warn</code>）。</p></blockquote><hr><p><strong>场景 1：给某个 Layer 的某个 Channel 设置自定义颜色</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 将 layer2 的 channel 3 设为橙色</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">setChannelColor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer2&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, { r: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, g: </span><span style="color:#79B8FF;">128</span><span style="color:#E1E4E8;">, b: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#6A737D;">// 效果：layer2 上所有用 channel 3 画的 mask 变为橙色</span></span>
<span class="line"><span style="color:#6A737D;">// layer1、layer3 的 channel 3 颜色不受影响</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 将 layer2 的 channel 3 设为橙色</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">setChannelColor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer2&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, { r: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, g: </span><span style="color:#005CC5;">128</span><span style="color:#24292E;">, b: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> });</span></span>
<span class="line"><span style="color:#6A737D;">// 效果：layer2 上所有用 channel 3 画的 mask 变为橙色</span></span>
<span class="line"><span style="color:#6A737D;">// layer1、layer3 的 channel 3 颜色不受影响</span></span></code></pre></div><hr><p><strong>场景 2：批量设置一个 Layer 的多个 Channel 颜色（推荐，只触发一次重渲染）</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">setChannelColors</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer1&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">: { r: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, g: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,   b: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,   a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> },   </span><span style="color:#6A737D;">// channel 1 → 红色</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">: { r: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,   g: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,   b: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> },   </span><span style="color:#6A737D;">// channel 2 → 蓝色</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">: { r: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, g: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, b: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,   a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> },   </span><span style="color:#6A737D;">// channel 3 → 黄色</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#6A737D;">// 只触发一次 reloadMasksFromVolume()，性能优于多次调用 setChannelColor()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">setChannelColors</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer1&#39;</span><span style="color:#24292E;">, {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">: { r: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, g: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,   b: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,   a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> },   </span><span style="color:#6A737D;">// channel 1 → 红色</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">: { r: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,   g: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,   b: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> },   </span><span style="color:#6A737D;">// channel 2 → 蓝色</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">: { r: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, g: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, b: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,   a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> },   </span><span style="color:#6A737D;">// channel 3 → 黄色</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#6A737D;">// 只触发一次 reloadMasksFromVolume()，性能优于多次调用 setChannelColor()</span></span></code></pre></div><hr><p><strong>场景 3：所有 Layer 的同一 Channel 使用相同颜色</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 把所有 layer 的 channel 1 统一改为红色</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">setAllLayersChannelColor</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, { r: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, g: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, b: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> });</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 把所有 layer 的 channel 1 统一改为红色</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">setAllLayersChannelColor</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, { r: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, g: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, b: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> });</span></span></code></pre></div><hr><p><strong>场景 4：读取当前颜色</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 读取 layer2 的 channel 3 当前颜色</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">rgba</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nrrdTools.</span><span style="color:#B392F0;">getChannelColor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer2&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// → { r: 255, g: 128, b: 0, a: 255 }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">hex</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nrrdTools.</span><span style="color:#B392F0;">getChannelHexColor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer2&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// → &quot;#ff8000&quot;  (用于 canvas fillStyle 或 CSS color)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">css</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nrrdTools.</span><span style="color:#B392F0;">getChannelCssColor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer2&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// → &quot;rgba(255,128,0,1.00)&quot;  (用于 Vue style binding)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 读取 layer2 的 channel 3 当前颜色</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">rgba</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nrrdTools.</span><span style="color:#6F42C1;">getChannelColor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer2&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// → { r: 255, g: 128, b: 0, a: 255 }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">hex</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nrrdTools.</span><span style="color:#6F42C1;">getChannelHexColor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer2&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// → &quot;#ff8000&quot;  (用于 canvas fillStyle 或 CSS color)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">css</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nrrdTools.</span><span style="color:#6F42C1;">getChannelCssColor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer2&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// → &quot;rgba(255,128,0,1.00)&quot;  (用于 Vue style binding)</span></span></code></pre></div><hr><p><strong>场景 5：重置颜色</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 重置 layer2 的 channel 3 为默认颜色</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">resetChannelColors</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer2&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 重置 layer2 的所有 channel 为默认颜色</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">resetChannelColors</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer2&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 重置所有 layer 的所有 channel 为默认颜色</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">resetChannelColors</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 重置 layer2 的 channel 3 为默认颜色</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">resetChannelColors</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer2&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 重置 layer2 的所有 channel 为默认颜色</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">resetChannelColors</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer2&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 重置所有 layer 的所有 channel 为默认颜色</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">resetChannelColors</span><span style="color:#24292E;">();</span></span></code></pre></div><hr><p><strong>场景 6：设置颜色后通知 Vue UI 刷新</strong></p><p>颜色修改后，canvas 会立即重渲染（<code>reloadMasksFromVolume()</code> 自动调用）。 但 Vue UI 中的 channel 颜色卡片（<code>LayerChannelSelector.vue</code>）需要手动触发刷新：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 在 Vue 组件中，拿到 composable 的 refreshChannelColors</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">refreshChannelColors</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">useLayerChannel</span><span style="color:#E1E4E8;">({ nrrdTools });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 设置颜色后调用 refresh，让 Vue UI 同步更新颜色显示</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">setChannelColor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer2&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, { r: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, g: </span><span style="color:#79B8FF;">128</span><span style="color:#E1E4E8;">, b: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#B392F0;">refreshChannelColors</span><span style="color:#E1E4E8;">();   </span><span style="color:#6A737D;">// 递增 colorVersion → 触发 dynamicChannelConfigs 重计算</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 在 Vue 组件中，拿到 composable 的 refreshChannelColors</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> { </span><span style="color:#005CC5;">refreshChannelColors</span><span style="color:#24292E;"> } </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">useLayerChannel</span><span style="color:#24292E;">({ nrrdTools });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 设置颜色后调用 refresh，让 Vue UI 同步更新颜色显示</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">setChannelColor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer2&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, { r: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, g: </span><span style="color:#005CC5;">128</span><span style="color:#24292E;">, b: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> });</span></span>
<span class="line"><span style="color:#6F42C1;">refreshChannelColors</span><span style="color:#24292E;">();   </span><span style="color:#6A737D;">// 递增 colorVersion → 触发 dynamicChannelConfigs 重计算</span></span></code></pre></div><p>或者监听 <code>onChannelColorChanged</code> 回调来自动刷新：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 在初始化时注册回调（nrrd_states 是 NrrdTools 内部状态，需通过 draw() 选项设置）</span></span>
<span class="line"><span style="color:#6A737D;">// ⚠️ 目前 onChannelColorChanged 挂载在 nrrd_states 上，暂不支持直接从外部设置</span></span>
<span class="line"><span style="color:#6A737D;">// 推荐方式：手动在 setChannelColor() 后调用 refreshChannelColors()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 在初始化时注册回调（nrrd_states 是 NrrdTools 内部状态，需通过 draw() 选项设置）</span></span>
<span class="line"><span style="color:#6A737D;">// ⚠️ 目前 onChannelColorChanged 挂载在 nrrd_states 上，暂不支持直接从外部设置</span></span>
<span class="line"><span style="color:#6A737D;">// 推荐方式：手动在 setChannelColor() 后调用 refreshChannelColors()</span></span></code></pre></div><hr><p><strong>场景 7：完整的初始化+颜色设置示例（Vue 组件中）</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// LeftPanelCore.vue 或其他父组件</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> emitter </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;@/plugins/custom-emitter&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 图像加载完成后（onFinishLoadAllCaseImages 事件）</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nrrdTools</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">Copper</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">NrrdTools</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">emitter.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Core:NrrdTools&#39;</span><span style="color:#E1E4E8;">, (</span><span style="color:#FFAB70;">tools</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  nrrdTools.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tools;</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">emitter.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Segmentation:FinishLoadAllCaseImages&#39;</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 此时 setAllSlices() 已调用完毕，MaskVolume 已初始化，可以安全设置颜色</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">nrrdTools.value) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 为 layer1 设置自定义颜色方案</span></span>
<span class="line"><span style="color:#E1E4E8;">  nrrdTools.value.</span><span style="color:#B392F0;">setChannelColors</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;layer1&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">: { r: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, g: </span><span style="color:#79B8FF;">80</span><span style="color:#E1E4E8;">,  b: </span><span style="color:#79B8FF;">80</span><span style="color:#E1E4E8;">,  a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> },   </span><span style="color:#6A737D;">// 浅红</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">: { r: </span><span style="color:#79B8FF;">80</span><span style="color:#E1E4E8;">,  g: </span><span style="color:#79B8FF;">180</span><span style="color:#E1E4E8;">, b: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;">, a: </span><span style="color:#79B8FF;">255</span><span style="color:#E1E4E8;"> },   </span><span style="color:#6A737D;">// 浅蓝</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// layer2 保持默认颜色，无需操作</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// LeftPanelCore.vue 或其他父组件</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> emitter </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;@/plugins/custom-emitter&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 图像加载完成后（onFinishLoadAllCaseImages 事件）</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nrrdTools</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">Copper</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">NrrdTools</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">emitter.</span><span style="color:#6F42C1;">on</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Core:NrrdTools&#39;</span><span style="color:#24292E;">, (</span><span style="color:#E36209;">tools</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  nrrdTools.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tools;</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">emitter.</span><span style="color:#6F42C1;">on</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Segmentation:FinishLoadAllCaseImages&#39;</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 此时 setAllSlices() 已调用完毕，MaskVolume 已初始化，可以安全设置颜色</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">nrrdTools.value) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 为 layer1 设置自定义颜色方案</span></span>
<span class="line"><span style="color:#24292E;">  nrrdTools.value.</span><span style="color:#6F42C1;">setChannelColors</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;layer1&#39;</span><span style="color:#24292E;">, {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">: { r: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, g: </span><span style="color:#005CC5;">80</span><span style="color:#24292E;">,  b: </span><span style="color:#005CC5;">80</span><span style="color:#24292E;">,  a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> },   </span><span style="color:#6A737D;">// 浅红</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">: { r: </span><span style="color:#005CC5;">80</span><span style="color:#24292E;">,  g: </span><span style="color:#005CC5;">180</span><span style="color:#24292E;">, b: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;">, a: </span><span style="color:#005CC5;">255</span><span style="color:#24292E;"> },   </span><span style="color:#6A737D;">// 浅蓝</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// layer2 保持默认颜色，无需操作</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><hr><p><strong>颜色值范围</strong></p><p><code>RGBAColor</code> 各字段取值 <code>0-255</code>（整数）：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RGBAColor</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">r</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 0-255</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">g</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 0-255</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">b</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 0-255</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">a</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">;  </span><span style="color:#6A737D;">// 0-255，255 = 完全不透明，0 = 完全透明</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RGBAColor</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">r</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">;  </span><span style="color:#6A737D;">// 0-255</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">g</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">;  </span><span style="color:#6A737D;">// 0-255</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">b</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">;  </span><span style="color:#6A737D;">// 0-255</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">a</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">;  </span><span style="color:#6A737D;">// 0-255，255 = 完全不透明，0 = 完全透明</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Channel <code>a</code>（alpha）决定 mask 的不透明度基准值。通常设为 <code>255</code>，实际渲染时还会乘以 <code>gui_states.drawing.globalAlpha</code>（默认 0.6）。</p><h3 id="_2-3-keyboard-history" tabindex="-1">2.3 Keyboard &amp; History <a class="header-anchor" href="#_2-3-keyboard-history" aria-label="Permalink to &quot;2.3 Keyboard &amp; History&quot;">​</a></h3><blockquote><p><strong>实现</strong>: 直接在 NrrdTools Facade 中（分区 4）。</p></blockquote><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>undo</code></td><td><code>(): void</code></td><td>撤销上一次绘画操作</td></tr><tr><td><code>redo</code></td><td><code>(): void</code></td><td>重做上一次撤销的操作</td></tr><tr><td><code>enterKeyboardConfig</code></td><td><code>(): void</code></td><td>进入键盘配置模式（抑制所有快捷键）</td></tr><tr><td><code>exitKeyboardConfig</code></td><td><code>(): void</code></td><td>退出键盘配置模式</td></tr><tr><td><code>setContrastShortcutEnabled</code></td><td><code>(enabled: boolean): void</code></td><td>启用/禁用 Contrast 快捷键</td></tr><tr><td><code>isContrastShortcutEnabled</code></td><td><code>(): boolean</code></td><td>Contrast 快捷键是否启用</td></tr><tr><td><code>setKeyboardSettings</code></td><td><code>(settings: Partial&lt;IKeyBoardSettings&gt;): void</code></td><td>更新键盘快捷键绑定</td></tr><tr><td><code>getKeyboardSettings</code></td><td><code>(): IKeyBoardSettings</code></td><td>获取当前键盘设置快照</td></tr></tbody></table><h3 id="_2-4-data-loading" tabindex="-1">2.4 Data Loading <a class="header-anchor" href="#_2-4-data-loading" aria-label="Permalink to &quot;2.4 Data Loading&quot;">​</a></h3><blockquote><p><strong>实现</strong>: <code>tools/DataLoader.ts</code>，NrrdTools 中一行委托。</p></blockquote><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>setAllSlices</code></td><td><code>(allSlices: Array&lt;nrrdSliceType&gt;): void</code></td><td><strong>入口函数</strong>：加载 NRRD 切片，初始化所有 MaskVolume 到正确尺寸</td></tr><tr><td><code>setMasksData</code></td><td><code>(masksData, loadingBar?): void</code></td><td>旧版加载方法（Legacy，待移除）</td></tr><tr><td><code>setMasksFromNIfTI</code></td><td><code>(layerVoxels: Map&lt;string, Uint8Array&gt;, loadingBar?): void</code></td><td>从 NIfTI 文件加载 mask 到 MaskVolume</td></tr></tbody></table><h3 id="_2-5-display-rendering" tabindex="-1">2.5 Display &amp; Rendering <a class="header-anchor" href="#_2-5-display-rendering" aria-label="Permalink to &quot;2.5 Display &amp; Rendering&quot;">​</a></h3><blockquote><p><strong>实现</strong>: <code>tools/SliceRenderPipeline.ts</code>，NrrdTools 中一行委托。</p></blockquote><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>resizePaintArea</code></td><td><code>(factor: number): void</code></td><td>调整画布缩放</td></tr><tr><td><code>reloadMasksFromVolume</code></td><td><code>(): void</code> (private)</td><td><strong>核心重渲染</strong>：从 MaskVolume 重新渲染所有 Layer 到 Canvas</td></tr><tr><td><code>flipDisplayImageByAxis</code></td><td><code>(): void</code></td><td>翻转 CT 图像以正确显示</td></tr><tr><td><code>redrawDisplayCanvas</code></td><td><code>(): void</code></td><td>重绘 contrast 图像到 displayCanvas</td></tr><tr><td><code>setEmptyCanvasSize</code></td><td><code>(axis?): void</code></td><td>根据 axis 设置 emptyCanvas 尺寸</td></tr></tbody></table><h3 id="_2-6-programmatic-sphere-placement" tabindex="-1">2.6 Programmatic Sphere Placement <a class="header-anchor" href="#_2-6-programmatic-sphere-placement" aria-label="Permalink to &quot;2.6 Programmatic Sphere Placement&quot;">​</a></h3><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>setCalculateDistanceSphere</code></td><td><code>(x: number, y: number, sliceIndex: number, cal_position: SphereType): void</code></td><td>编程式放置 calculator sphere，模拟完整的鼠标点击流程</td></tr></tbody></table><p><strong>参数</strong>:</p><ul><li><code>x</code>, <code>y</code> — 未缩放的图像空间坐标（方法内部会自动乘以 <code>sizeFactor</code>）</li><li><code>sliceIndex</code> — 目标切片索引</li><li><code>cal_position</code> — Sphere 类型: <code>&quot;tumour&quot;</code> / <code>&quot;skin&quot;</code> / <code>&quot;nipple&quot;</code> / <code>&quot;ribcage&quot;</code></li></ul><p><strong>内部流程</strong> (模拟 <code>DrawToolCore.handleSphereClick</code> + <code>pointerup</code>):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">setCalculateDistanceSphere(x, y, sliceIndex, cal_position)</span></span>
<span class="line"><span style="color:#e1e4e8;">  │</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├─ sphereRadius = 5</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├─ setSliceMoving(...)                          → 导航到目标切片</span></span>
<span class="line"><span style="color:#e1e4e8;">  │</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├─ --- simulate mouse-down ---</span></span>
<span class="line"><span style="color:#e1e4e8;">  │  ├─ mouseX = x * sizeFactor</span></span>
<span class="line"><span style="color:#e1e4e8;">  │  ├─ sphereOrigin[axis] = [mouseX, mouseY, sliceIndex]</span></span>
<span class="line"><span style="color:#e1e4e8;">  │  ├─ crosshairTool.setUpSphereOrigins(...)     → 计算三轴 origin</span></span>
<span class="line"><span style="color:#e1e4e8;">  │  ├─ tumourSphereOrigin = deepCopy(sphereOrigin)  → 按 cal_position 存储</span></span>
<span class="line"><span style="color:#e1e4e8;">  │  └─ drawCalculatorSphere(radius)              → 绘制预览</span></span>
<span class="line"><span style="color:#e1e4e8;">  │</span></span>
<span class="line"><span style="color:#e1e4e8;">  └─ --- simulate mouse-up ---</span></span>
<span class="line"><span style="color:#e1e4e8;">     ├─ sphereTool.writeAllCalculatorSpheresToVolume()  → 写入 sphereMaskVolume</span></span>
<span class="line"><span style="color:#e1e4e8;">     └─ sphereTool.refreshSphereCanvas()               → 重渲染 overlay</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">setCalculateDistanceSphere(x, y, sliceIndex, cal_position)</span></span>
<span class="line"><span style="color:#24292e;">  │</span></span>
<span class="line"><span style="color:#24292e;">  ├─ sphereRadius = 5</span></span>
<span class="line"><span style="color:#24292e;">  ├─ setSliceMoving(...)                          → 导航到目标切片</span></span>
<span class="line"><span style="color:#24292e;">  │</span></span>
<span class="line"><span style="color:#24292e;">  ├─ --- simulate mouse-down ---</span></span>
<span class="line"><span style="color:#24292e;">  │  ├─ mouseX = x * sizeFactor</span></span>
<span class="line"><span style="color:#24292e;">  │  ├─ sphereOrigin[axis] = [mouseX, mouseY, sliceIndex]</span></span>
<span class="line"><span style="color:#24292e;">  │  ├─ crosshairTool.setUpSphereOrigins(...)     → 计算三轴 origin</span></span>
<span class="line"><span style="color:#24292e;">  │  ├─ tumourSphereOrigin = deepCopy(sphereOrigin)  → 按 cal_position 存储</span></span>
<span class="line"><span style="color:#24292e;">  │  └─ drawCalculatorSphere(radius)              → 绘制预览</span></span>
<span class="line"><span style="color:#24292e;">  │</span></span>
<span class="line"><span style="color:#24292e;">  └─ --- simulate mouse-up ---</span></span>
<span class="line"><span style="color:#24292e;">     ├─ sphereTool.writeAllCalculatorSpheresToVolume()  → 写入 sphereMaskVolume</span></span>
<span class="line"><span style="color:#24292e;">     └─ sphereTool.refreshSphereCanvas()               → 重渲染 overlay</span></span></code></pre></div><p><strong>典型用法</strong> (后端返回 sphere 坐标后调用):</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 后端 AI 检测到 tumour 位置后，自动放置 sphere</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">setCalculateDistanceSphere</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">120</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">95</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">42</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;tumour&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">nrrdTools.</span><span style="color:#B392F0;">setCalculateDistanceSphere</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">150</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">42</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;skin&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 后端 AI 检测到 tumour 位置后，自动放置 sphere</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">setCalculateDistanceSphere</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">120</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">95</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">42</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;tumour&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">nrrdTools.</span><span style="color:#6F42C1;">setCalculateDistanceSphere</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">200</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">150</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">42</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;skin&#39;</span><span style="color:#24292E;">);</span></span></code></pre></div><h3 id="_2-7-其他-api" tabindex="-1">2.7 其他 API <a class="header-anchor" href="#_2-7-其他-api" aria-label="Permalink to &quot;2.7 其他 API&quot;">​</a></h3><blockquote><p><strong>实现</strong>: 直接在 NrrdTools Facade 中（分区 5 View Control、分区 6 Data Getters）。</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>drag(opts?)</code></td><td>启用拖拽切片功能</td></tr><tr><td><code>setBaseDrawDisplayCanvasesSize(size)</code></td><td>设置 Canvas 基础尺寸 (1-8)</td></tr><tr><td><code>setupGUI(gui)</code></td><td>设置 dat.gui 面板</td></tr><tr><td><code>enableContrastDragEvents(callback)</code></td><td>启用 contrast 拖拽事件</td></tr><tr><td><code>getCurrentImageDimension()</code></td><td>获取图像体素维度 <code>[w, h, d]</code></td></tr><tr><td><code>getVoxelSpacing()</code></td><td>获取体素间距 (mm)</td></tr><tr><td><code>getSpaceOrigin()</code></td><td>获取世界坐标系原点</td></tr><tr><td><code>getMaxSliceNum()</code></td><td>获取各轴最大切片数</td></tr><tr><td><code>getCurrentSlicesNumAndContrastNum()</code></td><td>获取当前切片索引和 contrast 索引</td></tr><tr><td><code>getMaskData()</code></td><td>获取 <code>IMaskData</code> 原始数据结构</td></tr><tr><td><code>getContainer()</code></td><td>获取内部主区域容器</td></tr><tr><td><code>getDrawingCanvas()</code></td><td>获取顶层交互 Canvas</td></tr><tr><td><code>getNrrdToolsSettings()</code></td><td>获取完整 NrrdState 快照（5 个子对象）</td></tr></tbody></table><hr><h2 id="_3-states-状态" tabindex="-1">3. States（状态） <a class="header-anchor" href="#_3-states-状态" aria-label="Permalink to &quot;3. States（状态）&quot;">​</a></h2><h3 id="_3-1-nrrd-states-nrrdstate" tabindex="-1">3.1 nrrd_states (NrrdState) <a class="header-anchor" href="#_3-1-nrrd-states-nrrdstate" aria-label="Permalink to &quot;3.1 nrrd_states (NrrdState)&quot;">​</a></h3><p><strong>类型</strong>: <code>NrrdState</code> class（定义: <a href="annotator-frontend/src/ts/Utils/segmentation/coreTools/NrrdState.ts">coreTools/NrrdState.ts</a>） <strong>接口</strong>: <code>INrrdStates</code> extends <code>IImageMetadata</code>, <code>IViewState</code>, <code>IInteractionState</code>, <code>ISphereState</code>, <code>IInternalFlags</code>（定义: <a href="annotator-frontend/src/ts/Utils/segmentation/core/types.ts">core/types.ts</a>）</p><p>NrrdState 将 44 个属性分组为 5 个语义子对象：</p><h4 id="nrrd-states-image-iimagemetadata" tabindex="-1">nrrd_states.image (IImageMetadata) <a class="header-anchor" href="#nrrd-states-image-iimagemetadata" aria-label="Permalink to &quot;nrrd_states.image (IImageMetadata)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>dimensions</code></td><td><code>[width, height, depth]</code></td><td>体素维度</td></tr><tr><td><code>nrrd_x_pixel</code> / <code>y</code> / <code>z</code></td><td><code>number</code></td><td>各轴像素数</td></tr><tr><td><code>voxelSpacing</code></td><td><code>number[]</code></td><td>体素间距</td></tr><tr><td><code>spaceOrigin</code></td><td><code>number[]</code></td><td>空间原点</td></tr><tr><td><code>layers</code></td><td><code>string[]</code></td><td>Layer ID 列表</td></tr></tbody></table><h4 id="nrrd-states-view-iviewstate" tabindex="-1">nrrd_states.view (IViewState) <a class="header-anchor" href="#nrrd-states-view-iviewstate" aria-label="Permalink to &quot;nrrd_states.view (IViewState)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>currentSliceIndex</code></td><td><code>number</code></td><td>当前切片索引</td></tr><tr><td><code>maxIndex</code> / <code>minIndex</code></td><td><code>number</code></td><td>切片索引范围</td></tr><tr><td><code>changedWidth</code> / <code>changedHeight</code></td><td><code>number</code></td><td>Canvas 显示尺寸</td></tr><tr><td><code>sizeFactor</code></td><td><code>number</code></td><td>缩放因子</td></tr><tr><td><code>originWidth</code> / <code>originHeight</code></td><td><code>number</code></td><td>原始图像尺寸</td></tr></tbody></table><h4 id="nrrd-states-interaction-iinteractionstate" tabindex="-1">nrrd_states.interaction (IInteractionState) <a class="header-anchor" href="#nrrd-states-interaction-iinteractionstate" aria-label="Permalink to &quot;nrrd_states.interaction (IInteractionState)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>mouseOverX</code> / <code>mouseOverY</code></td><td><code>number</code></td><td>鼠标位置</td></tr><tr><td><code>mouseOver</code></td><td><code>boolean</code></td><td>鼠标是否在画布上</td></tr><tr><td><code>cursorPageX</code> / <code>cursorPageY</code></td><td><code>number</code></td><td>光标页面坐标</td></tr><tr><td><code>drawStartPos</code></td><td><code>ICommXY</code></td><td>绘画起始点</td></tr></tbody></table><h4 id="nrrd-states-sphere-ispherestate" tabindex="-1">nrrd_states.sphere (ISphereState) <a class="header-anchor" href="#nrrd-states-sphere-ispherestate" aria-label="Permalink to &quot;nrrd_states.sphere (ISphereState)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>sphereOrigin</code> / <code>skinSphereOrigin</code> 等</td><td><code>ICommXYZ | null</code></td><td>各类型 sphere 原点</td></tr><tr><td><code>sphereRadius</code></td><td><code>number</code></td><td>sphere 半径</td></tr><tr><td><code>sphereMaskVolume</code></td><td><code>MaskVolume | null</code></td><td>sphere 体积数据</td></tr></tbody></table><h4 id="nrrd-states-flags-iinternalflags" tabindex="-1">nrrd_states.flags (IInternalFlags) <a class="header-anchor" href="#nrrd-states-flags-iinternalflags" aria-label="Permalink to &quot;nrrd_states.flags (IInternalFlags)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>stepClear</code></td><td><code>number</code></td><td>清除步长（内部用）</td></tr><tr><td><code>clearAllFlag</code></td><td><code>boolean</code></td><td>当前是否为全层清除操作</td></tr><tr><td><code>loadingMaskData</code></td><td><code>boolean</code></td><td>是否正在加载 mask 数据</td></tr></tbody></table><blockquote><p>⚠️ <code>loadMaskByDefault</code> 和 <code>isCalcContrastByDrag</code> 字段<strong>已不存在</strong>，文档之前有误。</p></blockquote><blockquote><p>⚠️ <code>INrrdStates</code> 扁平接口保留用于向后兼容（extends 所有 5 个子接口），但运行时使用 <code>NrrdState</code> 类实例，属性通过 <code>nrrd_states.image.xxx</code>、<code>nrrd_states.view.xxx</code> 等访问。</p></blockquote><h3 id="_3-2-gui-states-guistate" tabindex="-1">3.2 gui_states (GuiState) <a class="header-anchor" href="#_3-2-gui-states-guistate" aria-label="Permalink to &quot;3.2 gui_states (GuiState)&quot;">​</a></h3><p><strong>类型</strong>: <code>GuiState</code> class（定义: <a href="annotator-frontend/src/ts/Utils/segmentation/coreTools/GuiState.ts">coreTools/GuiState.ts</a>） <strong>接口</strong>: <code>IGUIStates</code> extends <code>IToolModeState</code>, <code>IDrawingConfig</code>, <code>IViewConfig</code>, <code>ILayerChannelState</code>（定义: <a href="annotator-frontend/src/ts/Utils/segmentation/core/types.ts">core/types.ts</a>）</p><p>GuiState 将 20 个属性分组为 4 个语义子对象：</p><h4 id="gui-states-mode-itoolmodestate" tabindex="-1">gui_states.mode (IToolModeState) <a class="header-anchor" href="#gui-states-mode-itoolmodestate" aria-label="Permalink to &quot;gui_states.mode (IToolModeState)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>pencil</code></td><td><code>boolean</code></td><td>铅笔工具激活</td></tr><tr><td><code>eraser</code></td><td><code>boolean</code></td><td>橡皮擦工具激活</td></tr><tr><td><code>sphere</code></td><td><code>boolean</code></td><td>球体工具激活</td></tr><tr><td><code>activeSphereType</code></td><td><code>&quot;tumour&quot; | &quot;skin&quot; | &quot;nipple&quot; | &quot;ribcage&quot;</code></td><td>当前 sphere 类型</td></tr></tbody></table><h4 id="gui-states-drawing-idrawingconfig" tabindex="-1">gui_states.drawing (IDrawingConfig) <a class="header-anchor" href="#gui-states-drawing-idrawingconfig" aria-label="Permalink to &quot;gui_states.drawing (IDrawingConfig)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>globalAlpha</code></td><td><code>number</code></td><td>全局透明度 (0.6)</td></tr><tr><td><code>lineWidth</code></td><td><code>number</code></td><td>线宽</td></tr><tr><td><code>color</code> / <code>fillColor</code> / <code>brushColor</code></td><td><code>string</code></td><td>画笔颜色 (Hex)</td></tr><tr><td><code>brushAndEraserSize</code></td><td><code>number</code></td><td>画笔/橡皮擦大小</td></tr></tbody></table><h4 id="gui-states-viewconfig-iviewconfig" tabindex="-1">gui_states.viewConfig (IViewConfig) <a class="header-anchor" href="#gui-states-viewconfig-iviewconfig" aria-label="Permalink to &quot;gui_states.viewConfig (IViewConfig)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>mainAreaSize</code></td><td><code>number</code></td><td>主区域大小</td></tr><tr><td><code>dragSensitivity</code></td><td><code>number</code></td><td>拖拽灵敏度</td></tr><tr><td><code>cursor</code> / <code>defaultPaintCursor</code></td><td><code>string</code></td><td>光标样式</td></tr><tr><td><code>readyToUpdate</code></td><td><code>boolean</code></td><td>准备更新标志</td></tr></tbody></table><h4 id="gui-states-layerchannel-ilayerchannelstate" tabindex="-1">gui_states.layerChannel (ILayerChannelState) <a class="header-anchor" href="#gui-states-layerchannel-ilayerchannelstate" aria-label="Permalink to &quot;gui_states.layerChannel (ILayerChannelState)&quot;">​</a></h4><table><thead><tr><th>字段</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>layer</code></td><td><code>string</code></td><td>当前活跃 Layer (默认 <code>&quot;layer1&quot;</code>)</td></tr><tr><td><code>activeChannel</code></td><td><code>number</code></td><td>当前活跃 Channel (1-8)</td></tr><tr><td><code>layerVisibility</code></td><td><code>Record&lt;string, boolean&gt;</code></td><td>Layer 可见性</td></tr><tr><td><code>channelVisibility</code></td><td><code>Record&lt;string, Record&lt;number, boolean&gt;&gt;</code></td><td>Channel 可见性</td></tr></tbody></table><h3 id="_3-3-protecteddata-iprotected" tabindex="-1">3.3 protectedData (IProtected) <a class="header-anchor" href="#_3-3-protecteddata-iprotected" aria-label="Permalink to &quot;3.3 protectedData (IProtected)&quot;">​</a></h3><p>定义位置: <a href="annotator-frontend/src/ts/Utils/segmentation/CanvasState.ts">CanvasState.ts</a> constructor</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>axis</code></td><td>当前视图轴 <code>&quot;x&quot;</code> / <code>&quot;y&quot;</code> / <code>&quot;z&quot;</code></td></tr><tr><td><code>maskData.volumes</code></td><td><code>Record&lt;string, MaskVolume&gt;</code> — 每个 Layer 对应的 3D 体积</td></tr><tr><td><code>layerTargets</code></td><td><code>Map&lt;string, ILayerRenderTarget&gt;</code> — 每个 Layer 的 canvas+ctx</td></tr><tr><td><code>canvases</code></td><td>5 个系统 Canvas</td></tr><tr><td><code>ctxes</code></td><td>对应的 2D Context</td></tr><tr><td><code>isDrawing</code></td><td>当前是否正在绘画</td></tr></tbody></table><blockquote><p>⚠️ <code>Is_Shift_Pressed</code> / <code>Is_Ctrl_Pressed</code> 已删除，键盘修饰键状态现在由 <code>EventRouter</code> 内部管理，不再暴露到 <code>protectedData</code>。</p></blockquote><hr><h2 id="_4-callbacks" tabindex="-1">4. Callbacks <a class="header-anchor" href="#_4-callbacks" aria-label="Permalink to &quot;4. Callbacks&quot;">​</a></h2><h3 id="_4-1-onmaskchanged-getmaskdata-后端同步" tabindex="-1">4.1 onMaskChanged / getMaskData (后端同步) <a class="header-anchor" href="#_4-1-onmaskchanged-getmaskdata-后端同步" aria-label="Permalink to &quot;4.1 onMaskChanged / getMaskData (后端同步)&quot;">​</a></h3><p>存储位置: <code>CanvasState.annotationCallbacks.onMaskChanged</code>（<code>IAnnotationCallbacks</code> 接口）</p><blockquote><p>⚠️ <strong>注意</strong>: 原文档中的 <code>nrrd_states.getMask</code> 字段已不存在。外部通过 <code>nrrdTools.draw({ getMaskData: ... })</code> 注册，内部映射到 <code>annotationCallbacks.onMaskChanged</code>。</p></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// IAnnotationCallbacks 接口 (core/types.ts)</span></span>
<span class="line"><span style="color:#B392F0;">onMaskChanged</span><span style="color:#E1E4E8;">: (</span></span>
<span class="line"><span style="color:#E1E4E8;">  sliceData: Uint8Array,    </span><span style="color:#6A737D;">// 当前切片的原始体素数据</span></span>
<span class="line"><span style="color:#E1E4E8;">  layerId: string,          </span><span style="color:#6A737D;">// layer 名</span></span>
<span class="line"><span style="color:#E1E4E8;">  channelId: number,        </span><span style="color:#6A737D;">// active channel</span></span>
<span class="line"><span style="color:#E1E4E8;">  sliceIndex: number,       </span><span style="color:#6A737D;">// 切片索引</span></span>
<span class="line"><span style="color:#E1E4E8;">  axis: </span><span style="color:#9ECBFF;">&quot;x&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;y&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;z&quot;</span><span style="color:#E1E4E8;">,   </span><span style="color:#6A737D;">// 当前轴</span></span>
<span class="line"><span style="color:#E1E4E8;">  width: number,            </span><span style="color:#6A737D;">// 切片宽度</span></span>
<span class="line"><span style="color:#E1E4E8;">  height: number,           </span><span style="color:#6A737D;">// 切片高度</span></span>
<span class="line"><span style="color:#E1E4E8;">  clearFlag: boolean        </span><span style="color:#6A737D;">// 是否为清除操作</span></span>
<span class="line"><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// IAnnotationCallbacks 接口 (core/types.ts)</span></span>
<span class="line"><span style="color:#6F42C1;">onMaskChanged</span><span style="color:#24292E;">: (</span></span>
<span class="line"><span style="color:#24292E;">  sliceData: Uint8Array,    </span><span style="color:#6A737D;">// 当前切片的原始体素数据</span></span>
<span class="line"><span style="color:#24292E;">  layerId: string,          </span><span style="color:#6A737D;">// layer 名</span></span>
<span class="line"><span style="color:#24292E;">  channelId: number,        </span><span style="color:#6A737D;">// active channel</span></span>
<span class="line"><span style="color:#24292E;">  sliceIndex: number,       </span><span style="color:#6A737D;">// 切片索引</span></span>
<span class="line"><span style="color:#24292E;">  axis: </span><span style="color:#032F62;">&quot;x&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;y&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;z&quot;</span><span style="color:#24292E;">,   </span><span style="color:#6A737D;">// 当前轴</span></span>
<span class="line"><span style="color:#24292E;">  width: number,            </span><span style="color:#6A737D;">// 切片宽度</span></span>
<span class="line"><span style="color:#24292E;">  height: number,           </span><span style="color:#6A737D;">// 切片高度</span></span>
<span class="line"><span style="color:#24292E;">  clearFlag: boolean        </span><span style="color:#6A737D;">// 是否为清除操作</span></span>
<span class="line"><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span></span></code></pre></div><p><strong>调用时机</strong>: 每次绘画结束（mouseup）、undo/redo 之后。</p><h3 id="_4-2-onlayervolumecleared" tabindex="-1">4.2 onLayerVolumeCleared <a class="header-anchor" href="#_4-2-onlayervolumecleared" aria-label="Permalink to &quot;4.2 onLayerVolumeCleared&quot;">​</a></h3><p>存储位置: <code>CanvasState.annotationCallbacks.onLayerVolumeCleared</code></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">onLayerVolumeCleared</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">layerId</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">onLayerVolumeCleared</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">layerId</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span></span></code></pre></div><h3 id="_4-3-onchannelcolorchanged-phase-b-新增" tabindex="-1">4.3 onChannelColorChanged（Phase B 新增） <a class="header-anchor" href="#_4-3-onchannelcolorchanged-phase-b-新增" aria-label="Permalink to &quot;4.3 onChannelColorChanged（Phase B 新增）&quot;">​</a></h3><p>存储位置: <code>CanvasState.annotationCallbacks.onChannelColorChanged</code>（<code>IAnnotationCallbacks</code> 接口，<code>core/types.ts</code>）</p><blockquote><p>⚠️ <strong>注意</strong>: 原文档说定义在 <code>INrrdStates</code> 上，<strong>已不正确</strong>。该回调现在属于 <code>IAnnotationCallbacks</code>，存储在 <code>CanvasState.annotationCallbacks</code> 中，不在 <code>nrrd_states</code> 上。</p></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">onChannelColorChanged</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">layerId</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">channel</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">color</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RGBAColor</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">onChannelColorChanged</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">layerId</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">, </span><span style="color:#E36209;">channel</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">, </span><span style="color:#E36209;">color</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RGBAColor</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span></span></code></pre></div><p><strong>调用时机</strong>: <code>NrrdTools.setChannelColor()</code> 修改颜色后触发。默认空实现，暂不支持从外部直接注册（推荐通过 <code>setChannelColor()</code> 后手动调用 <code>refreshChannelColors()</code> 刷新 Vue UI）。</p><h3 id="_4-4-onspherechanged-oncalculatorpositionschanged" tabindex="-1">4.4 onSphereChanged / onCalculatorPositionsChanged <a class="header-anchor" href="#_4-4-onspherechanged-oncalculatorpositionschanged" aria-label="Permalink to &quot;4.4 onSphereChanged / onCalculatorPositionsChanged&quot;">​</a></h3><p>存储位置: <code>CanvasState.annotationCallbacks</code>（<code>IAnnotationCallbacks</code>，外部通过 <code>draw()</code> 注册）</p><p><strong><code>onSphereChanged</code></strong> (<code>getSphereData</code> in <code>IDrawOpts</code>): Sphere 模式下左键松开时调用。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">onSphereChanged</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">sphereOrigin</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">[], </span><span style="color:#FFAB70;">sphereRadius</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span></span>
<span class="line"><span style="color:#6A737D;">// sphereOrigin = [mouseX, mouseY, sliceIndex] — z-axis 坐标</span></span>
<span class="line"><span style="color:#6A737D;">// sphereRadius = 半径 (1-50 像素)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">onSphereChanged</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">sphereOrigin</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">[], </span><span style="color:#E36209;">sphereRadius</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span></span>
<span class="line"><span style="color:#6A737D;">// sphereOrigin = [mouseX, mouseY, sliceIndex] — z-axis 坐标</span></span>
<span class="line"><span style="color:#6A737D;">// sphereRadius = 半径 (1-50 像素)</span></span></code></pre></div><p><strong><code>onCalculatorPositionsChanged</code></strong> (<code>getCalculateSpherePositionsData</code> in <code>IDrawOpts</code>): Sphere 模式下放置 sphere 后调用（所有类型通用）。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">onCalculatorPositionsChanged</span><span style="color:#E1E4E8;">: (</span></span>
<span class="line"><span style="color:#E1E4E8;">  tumourSphereOrigin: ICommXYZ </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,  </span><span style="color:#6A737D;">// channel 1</span></span>
<span class="line"><span style="color:#E1E4E8;">  skinSphereOrigin: ICommXYZ </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,    </span><span style="color:#6A737D;">// channel 4</span></span>
<span class="line"><span style="color:#E1E4E8;">  ribSphereOrigin: ICommXYZ </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,     </span><span style="color:#6A737D;">// channel 3</span></span>
<span class="line"><span style="color:#E1E4E8;">  nippleSphereOrigin: ICommXYZ </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,  </span><span style="color:#6A737D;">// channel 2</span></span>
<span class="line"><span style="color:#E1E4E8;">  axis: </span><span style="color:#9ECBFF;">&quot;x&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;y&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;z&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span></span>
<span class="line"><span style="color:#6A737D;">// 每个 origin 为 { x: [mx, my, slice], y: [...], z: [...] }</span></span>
<span class="line"><span style="color:#6A737D;">// null 表示该类型尚未放置</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">onCalculatorPositionsChanged</span><span style="color:#24292E;">: (</span></span>
<span class="line"><span style="color:#24292E;">  tumourSphereOrigin: ICommXYZ </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,  </span><span style="color:#6A737D;">// channel 1</span></span>
<span class="line"><span style="color:#24292E;">  skinSphereOrigin: ICommXYZ </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,    </span><span style="color:#6A737D;">// channel 4</span></span>
<span class="line"><span style="color:#24292E;">  ribSphereOrigin: ICommXYZ </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,     </span><span style="color:#6A737D;">// channel 3</span></span>
<span class="line"><span style="color:#24292E;">  nippleSphereOrigin: ICommXYZ </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,  </span><span style="color:#6A737D;">// channel 2</span></span>
<span class="line"><span style="color:#24292E;">  axis: </span><span style="color:#032F62;">&quot;x&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;y&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;z&quot;</span></span>
<span class="line"><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span></span>
<span class="line"><span style="color:#6A737D;">// 每个 origin 为 { x: [mx, my, slice], y: [...], z: [...] }</span></span>
<span class="line"><span style="color:#6A737D;">// null 表示该类型尚未放置</span></span></code></pre></div><p><strong>Channel 映射</strong> (exported as <code>SPHERE_CHANNEL_MAP</code>):</p><table><thead><tr><th>Sphere Type</th><th>Layer</th><th>Channel</th><th>颜色</th></tr></thead><tbody><tr><td>tumour</td><td>layer1</td><td>1</td><td><code>#10b981</code> (Emerald)</td></tr><tr><td>nipple</td><td>layer1</td><td>2</td><td><code>#f43f5e</code> (Rose)</td></tr><tr><td>ribcage</td><td>layer1</td><td>3</td><td><code>#3b82f6</code> (Blue)</td></tr><tr><td>skin</td><td>layer1</td><td>4</td><td><code>#fbbf24</code> (Amber)</td></tr></tbody></table><blockquote><p>⚠️ 当前 sphere 数据不写入 layer MaskVolume，仅作为 overlay 显示。Channel 映射预留供未来使用。</p></blockquote><hr><h2 id="_5-maskvolume-存储与渲染" tabindex="-1">5. MaskVolume 存储与渲染 <a class="header-anchor" href="#_5-maskvolume-存储与渲染" aria-label="Permalink to &quot;5. MaskVolume 存储与渲染&quot;">​</a></h2><h3 id="_5-1-内存布局" tabindex="-1">5.1 内存布局 <a class="header-anchor" href="#_5-1-内存布局" aria-label="Permalink to &quot;5.1 内存布局&quot;">​</a></h3><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts">core/MaskVolume.ts</a></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">内存布局: [z][y][x][channel]</span></span>
<span class="line"><span style="color:#e1e4e8;">index = z * bytesPerSlice + y * width * channels + x * channels + channel</span></span>
<span class="line"><span style="color:#e1e4e8;">bytesPerSlice = width * height * channels</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">内存布局: [z][y][x][channel]</span></span>
<span class="line"><span style="color:#24292e;">index = z * bytesPerSlice + y * width * channels + x * channels + channel</span></span>
<span class="line"><span style="color:#24292e;">bytesPerSlice = width * height * channels</span></span></code></pre></div><p>底层数据结构: 单一连续 <code>Uint8Array</code></p><h3 id="_5-2-各轴切片维度" tabindex="-1">5.2 各轴切片维度 <a class="header-anchor" href="#_5-2-各轴切片维度" aria-label="Permalink to &quot;5.2 各轴切片维度&quot;">​</a></h3><p>定义: <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L1117-L1126">MaskVolume.ts:1117-1126</a></p><table><thead><tr><th>轴</th><th>切片宽度</th><th>切片高度</th><th>说明</th></tr></thead><tbody><tr><td>z (Axial)</td><td>width</td><td>height</td><td>最常用，连续内存</td></tr><tr><td>y (Coronal)</td><td>width</td><td>depth</td><td>按行提取</td></tr><tr><td>x (Sagittal)</td><td>depth</td><td>height</td><td>逐像素提取，最慢</td></tr></tbody></table><p>对应 emptyCanvas 尺寸设置: <code>SliceRenderPipeline.setEmptyCanvasSize()</code> → <a href="annotator-frontend/src/ts/Utils/segmentation/tools/SliceRenderPipeline.ts">tools/SliceRenderPipeline.ts</a>（已从 NrrdTools 提取）</p><h3 id="_5-3-切片提取-读取-mask" tabindex="-1">5.3 切片提取 (读取 Mask) <a class="header-anchor" href="#_5-3-切片提取-读取-mask" aria-label="Permalink to &quot;5.3 切片提取 (读取 Mask)&quot;">​</a></h3><p><strong><code>getSliceUint8(sliceIndex, axis)</code></strong> — <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L1019-L1058">MaskVolume.ts:1019-1058</a></p><p>返回原始 <code>Uint8Array</code>，用于：</p><ul><li>后端同步 (<code>getMask</code> callback)</li><li>Undo/Redo 快照</li></ul><p>各轴实现：</p><ul><li><strong>Z 轴</strong> <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L1032-L1035">L1032-1035</a>: 连续内存 <code>subarray</code> 批量复制（最快）</li><li><strong>Y 轴</strong> <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L1036-L1042">L1036-1042</a>: 按行迭代复制</li><li><strong>X 轴</strong> <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L1043-L1055">L1043-1055</a>: 逐像素提取（最慢）</li></ul><h3 id="_5-4-切片写入" tabindex="-1">5.4 切片写入 <a class="header-anchor" href="#_5-4-切片写入" aria-label="Permalink to &quot;5.4 切片写入&quot;">​</a></h3><p><strong><code>setSliceUint8(sliceIndex, data, axis)</code></strong> — <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L1072-L1108">MaskVolume.ts:1072-1108</a></p><p><code>getSliceUint8</code> 的逆操作，用于 Undo/Redo 恢复。</p><p><strong><code>setSliceLabelsFromImageData(sliceIndex, imageData, axis, activeChannel, channelVisible?)</code></strong> — <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L575-L661">MaskVolume.ts:575-661</a></p><p>Canvas→Volume 写入，将 RGBA 像素转换为 channel label (1-8)。</p><ul><li>构建 RGB→Channel 映射 <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L593">L593</a></li><li>ALPHA_THRESHOLD = 128 <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L601">L601</a> 避免抗锯齿边缘</li></ul><h3 id="_5-5-渲染到-canvas" tabindex="-1">5.5 渲染到 Canvas <a class="header-anchor" href="#_5-5-渲染到-canvas" aria-label="Permalink to &quot;5.5 渲染到 Canvas&quot;">​</a></h3><p><strong>核心渲染方法: <code>renderLabelSliceInto()</code></strong> — <a href="./annotator-frontend/src/ts/Utils/segmentation/core/MaskVolume.ts.html#L695-L770">MaskVolume.ts:695-770</a></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">renderLabelSliceInto</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  sliceIndex: number,</span></span>
<span class="line"><span style="color:#E1E4E8;">  axis: </span><span style="color:#9ECBFF;">&#39;x&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;y&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;z&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  target: ImageData,              </span><span style="color:#6A737D;">// 预分配的 ImageData buffer</span></span>
<span class="line"><span style="color:#E1E4E8;">  channelVisible</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> Record</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">number, boolean</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">,  </span><span style="color:#6A737D;">// Channel 可见性</span></span>
<span class="line"><span style="color:#E1E4E8;">  opacity: number </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1.0</span></span>
<span class="line"><span style="color:#E1E4E8;">): </span><span style="color:#F97583;">void</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">renderLabelSliceInto</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  sliceIndex: number,</span></span>
<span class="line"><span style="color:#24292E;">  axis: </span><span style="color:#032F62;">&#39;x&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;y&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;z&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  target: ImageData,              </span><span style="color:#6A737D;">// 预分配的 ImageData buffer</span></span>
<span class="line"><span style="color:#24292E;">  channelVisible</span><span style="color:#D73A49;">?:</span><span style="color:#24292E;"> Record</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">number, boolean</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">,  </span><span style="color:#6A737D;">// Channel 可见性</span></span>
<span class="line"><span style="color:#24292E;">  opacity: number </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1.0</span></span>
<span class="line"><span style="color:#24292E;">): </span><span style="color:#D73A49;">void</span></span></code></pre></div><p>渲染逻辑:</p><ol><li>读取 label 值 (0-8)</li><li><code>label === 0</code> → 透明 (RGBA 全 0)</li><li><code>channelVisible &amp;&amp; !channelVisible[label]</code> → 隐藏该 Channel → 透明</li><li>否则 → 从 volume 的 <code>colorMap</code> 取颜色（支持 per-layer 自定义颜色），应用 opacity</li></ol><blockquote><p><strong>Phase B 变更</strong>: 颜色来源从全局 <code>MASK_CHANNEL_COLORS</code> 改为每个 volume 实例的 <code>this.colorMap</code>。<code>buildRgbToChannelMap()</code> 也改为 instance 方法，确保 canvas→volume 写回时使用正确的自定义颜色映射。</p></blockquote><h3 id="_5-6-渲染管线完整流程" tabindex="-1">5.6 渲染管线完整流程 <a class="header-anchor" href="#_5-6-渲染管线完整流程" aria-label="Permalink to &quot;5.6 渲染管线完整流程&quot;">​</a></h3><p><strong>入口: <code>reloadMasksFromVolume()</code></strong> — <code>SliceRenderPipeline.reloadMasksFromVolume()</code> → <a href="annotator-frontend/src/ts/Utils/segmentation/tools/SliceRenderPipeline.ts">tools/SliceRenderPipeline.ts</a>（已从 NrrdTools 提取，NrrdTools 中为 private 委托）</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">reloadMasksFromVolume()</span></span>
<span class="line"><span style="color:#e1e4e8;">  │</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├─ getOrCreateSliceBuffer(axis)          → 获取/创建可复用的 ImageData buffer</span></span>
<span class="line"><span style="color:#e1e4e8;">  │   [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#e1e4e8;">  │</span></span>
<span class="line"><span style="color:#e1e4e8;">  ├─ FOR EACH layer:</span></span>
<span class="line"><span style="color:#e1e4e8;">  │   ├─ target.ctx.clearRect(...)         → 清空 layer canvas</span></span>
<span class="line"><span style="color:#e1e4e8;">  │   └─ renderSliceToCanvas(layerId, axis, sliceIndex, buffer, target.ctx, w, h)</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       │</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       ├─ volume.renderLabelSliceInto(sliceIndex, axis, buffer, channelVis)</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       │   [MaskVolume.ts]              → 渲染体素到 buffer</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       │</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       ├─ emptyCtx.putImageData(buffer) → 放到 emptyCanvas</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       │   [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       │</span></span>
<span class="line"><span style="color:#e1e4e8;">  │       └─ targetCtx.drawImage(emptyCanvas, ...) → 绘制到 layer canvas</span></span>
<span class="line"><span style="color:#e1e4e8;">  │           [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#e1e4e8;">  │           ⚠️ 注意：冠状面（axis=&#39;y&#39;）会做 scale(1,-1) 垂直翻转（详见 §6.2）</span></span>
<span class="line"><span style="color:#e1e4e8;">  │</span></span>
<span class="line"><span style="color:#e1e4e8;">  └─ compositeAllLayers()                  → 合成到 master canvas</span></span>
<span class="line"><span style="color:#e1e4e8;">      [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#e1e4e8;">      │</span></span>
<span class="line"><span style="color:#e1e4e8;">      ├─ masterCtx.clearRect(...)</span></span>
<span class="line"><span style="color:#e1e4e8;">      └─ FOR EACH layer:</span></span>
<span class="line"><span style="color:#e1e4e8;">          ├─ if !layerVisibility[layerId] → skip</span></span>
<span class="line"><span style="color:#e1e4e8;">          └─ masterCtx.drawImage(layerCanvas)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">reloadMasksFromVolume()</span></span>
<span class="line"><span style="color:#24292e;">  │</span></span>
<span class="line"><span style="color:#24292e;">  ├─ getOrCreateSliceBuffer(axis)          → 获取/创建可复用的 ImageData buffer</span></span>
<span class="line"><span style="color:#24292e;">  │   [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#24292e;">  │</span></span>
<span class="line"><span style="color:#24292e;">  ├─ FOR EACH layer:</span></span>
<span class="line"><span style="color:#24292e;">  │   ├─ target.ctx.clearRect(...)         → 清空 layer canvas</span></span>
<span class="line"><span style="color:#24292e;">  │   └─ renderSliceToCanvas(layerId, axis, sliceIndex, buffer, target.ctx, w, h)</span></span>
<span class="line"><span style="color:#24292e;">  │       [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#24292e;">  │       │</span></span>
<span class="line"><span style="color:#24292e;">  │       ├─ volume.renderLabelSliceInto(sliceIndex, axis, buffer, channelVis)</span></span>
<span class="line"><span style="color:#24292e;">  │       │   [MaskVolume.ts]              → 渲染体素到 buffer</span></span>
<span class="line"><span style="color:#24292e;">  │       │</span></span>
<span class="line"><span style="color:#24292e;">  │       ├─ emptyCtx.putImageData(buffer) → 放到 emptyCanvas</span></span>
<span class="line"><span style="color:#24292e;">  │       │   [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#24292e;">  │       │</span></span>
<span class="line"><span style="color:#24292e;">  │       └─ targetCtx.drawImage(emptyCanvas, ...) → 绘制到 layer canvas</span></span>
<span class="line"><span style="color:#24292e;">  │           [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#24292e;">  │           ⚠️ 注意：冠状面（axis=&#39;y&#39;）会做 scale(1,-1) 垂直翻转（详见 §6.2）</span></span>
<span class="line"><span style="color:#24292e;">  │</span></span>
<span class="line"><span style="color:#24292e;">  └─ compositeAllLayers()                  → 合成到 master canvas</span></span>
<span class="line"><span style="color:#24292e;">      [RenderingUtils.ts]</span></span>
<span class="line"><span style="color:#24292e;">      │</span></span>
<span class="line"><span style="color:#24292e;">      ├─ masterCtx.clearRect(...)</span></span>
<span class="line"><span style="color:#24292e;">      └─ FOR EACH layer:</span></span>
<span class="line"><span style="color:#24292e;">          ├─ if !layerVisibility[layerId] → skip</span></span>
<span class="line"><span style="color:#24292e;">          └─ masterCtx.drawImage(layerCanvas)</span></span></code></pre></div><hr><h2 id="_6-翻转-flip-机制" tabindex="-1">6. 翻转 (Flip) 机制 <a class="header-anchor" href="#_6-翻转-flip-机制" aria-label="Permalink to &quot;6. 翻转 (Flip) 机制&quot;">​</a></h2><h3 id="_6-1-display-翻转-仅-ct-mri-图像" tabindex="-1">6.1 Display 翻转（仅 CT/MRI 图像） <a class="header-anchor" href="#_6-1-display-翻转-仅-ct-mri-图像" aria-label="Permalink to &quot;6.1 Display 翻转（仅 CT/MRI 图像）&quot;">​</a></h3><p><strong><code>flipDisplayImageByAxis()</code></strong> — <code>SliceRenderPipeline.flipDisplayImageByAxis()</code> → <a href="annotator-frontend/src/ts/Utils/segmentation/tools/SliceRenderPipeline.ts">tools/SliceRenderPipeline.ts</a>（已从 NrrdTools 提取）</p><p>因为 Three.js 渲染的切片不在正确的 2D 位置，需要翻转 displayCanvas：</p><table><thead><tr><th>轴</th><th>翻转方式</th></tr></thead><tbody><tr><td>x (Sagittal)</td><td><code>scale(-1, -1)</code> + <code>translate(-w, -h)</code></td></tr><tr><td>y (Coronal)</td><td><code>scale(1, -1)</code> + <code>translate(0, -h)</code></td></tr><tr><td>z (Axial)</td><td><code>scale(1, -1)</code> + <code>translate(0, -h)</code></td></tr></tbody></table><p>调用位置: <code>SliceRenderPipeline.redrawDisplayCanvas()</code> → 内部调用 <code>flipDisplayImageByAxis()</code></p><h3 id="_6-2-mask-翻转-仅冠状面" tabindex="-1">6.2 Mask 翻转（仅冠状面） <a class="header-anchor" href="#_6-2-mask-翻转-仅冠状面" aria-label="Permalink to &quot;6.2 Mask 翻转（仅冠状面）&quot;">​</a></h3><p><strong>重要</strong>: <code>renderSliceToCanvas()</code>（RenderingUtils.ts）中 Mask 渲染<strong>对冠状面（axis=&#39;y&#39;）做垂直翻转</strong>：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// RenderingUtils.renderSliceToCanvas() — Y 轴翻转：</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (axis </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;y&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  targetCtx.</span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  targetCtx.</span><span style="color:#B392F0;">scale</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  targetCtx.</span><span style="color:#B392F0;">translate</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">scaledHeight);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">targetCtx.</span><span style="color:#B392F0;">drawImage</span><span style="color:#E1E4E8;">(emptyCanvas, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, scaledWidth, scaledHeight);</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (axis </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;y&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  targetCtx.</span><span style="color:#B392F0;">restore</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// RenderingUtils.renderSliceToCanvas() — Y 轴翻转：</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (axis </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;y&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  targetCtx.</span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  targetCtx.</span><span style="color:#6F42C1;">scale</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  targetCtx.</span><span style="color:#6F42C1;">translate</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">scaledHeight);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">targetCtx.</span><span style="color:#6F42C1;">drawImage</span><span style="color:#24292E;">(emptyCanvas, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, scaledWidth, scaledHeight);</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (axis </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;y&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  targetCtx.</span><span style="color:#6F42C1;">restore</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><table><thead><tr><th>轴</th><th>Mask 翻转</th><th>说明</th></tr></thead><tbody><tr><td>z (Axial)</td><td><strong>无翻转</strong></td><td>存储坐标与 Three.js 切片一致</td></tr><tr><td>y (Coronal)</td><td><strong>垂直翻转</strong> <code>scale(1,-1)</code></td><td>与写入路径（syncLayerSliceData）的翻转对消，保证跨轴显示一致</td></tr><tr><td>x (Sagittal)</td><td><strong>无翻转</strong></td><td>存储坐标与 Three.js 切片一致</td></tr></tbody></table><blockquote><p>⚠️ 原文档描述&quot;Mask 不翻转&quot;已过时。冠状面引入了 Y 轴翻转以修复跨轴切片对齐 bug。</p></blockquote><h3 id="_6-3-applymaskflipforaxis-辅助方法" tabindex="-1">6.3 applyMaskFlipForAxis（辅助方法） <a class="header-anchor" href="#_6-3-applymaskflipforaxis-辅助方法" aria-label="Permalink to &quot;6.3 applyMaskFlipForAxis（辅助方法）&quot;">​</a></h3><p><code>RenderingUtils.applyMaskFlipForAxis()</code> — 提供与 <code>flipDisplayImageByAxis()</code> 相同的翻转变换，可供需要手动对齐坐标的场景使用。目前在主渲染路径中的具体冠状面翻转已内联到 <code>renderSliceToCanvas()</code>。</p><hr><h2 id="_7-tools-工具" tabindex="-1">7. Tools（工具） <a class="header-anchor" href="#_7-tools-工具" aria-label="Permalink to &quot;7. Tools（工具）&quot;">​</a></h2><p>位置: <code>annotator-frontend/src/ts/Utils/segmentation/tools/</code></p><p>所有 Tool / 模块继承自 <code>BaseTool</code>:</p><p><strong>BaseTool</strong> — <a href="annotator-frontend/src/ts/Utils/segmentation/tools/BaseTool.ts">tools/BaseTool.ts</a></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ToolContext</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">nrrd_states</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NrrdState</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">gui_states</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">GuiState</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">protectedData</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IProtected</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">cursorPage</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ICursorPage</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">callbacks</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IAnnotationCallbacks</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">abstract</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BaseTool</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ctx</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ToolContext</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">setContext</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ctx</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ToolContext</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">void</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ToolContext</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">nrrd_states</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NrrdState</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">gui_states</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">GuiState</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">protectedData</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IProtected</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">cursorPage</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ICursorPage</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">callbacks</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IAnnotationCallbacks</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">abstract</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BaseTool</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">ctx</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ToolContext</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">setContext</span><span style="color:#24292E;">(</span><span style="color:#E36209;">ctx</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ToolContext</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">void</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="_7-1-tool-列表" tabindex="-1">7.1 Tool 列表 <a class="header-anchor" href="#_7-1-tool-列表" aria-label="Permalink to &quot;7.1 Tool 列表&quot;">​</a></h3><blockquote><p><strong>ToolHost 统一接口（已完成）</strong>: 所有 Tool 的宿主方法依赖已统一到 <code>tools/ToolHost.ts</code> 中的 <code>ToolHost</code> 接口。每个 Tool 通过 <code>Pick&lt;ToolHost, ...&gt;</code> 类型别名（如 <code>SphereHostDeps</code>、<code>DrawingHostDeps</code>）声明所需方法子集，构造函数接收该子集类型的 callbacks 参数。原先的 10 个独立 <code>*Callbacks</code> 接口已全部删除。</p></blockquote><h4 id="nrrdtools-提取模块-god-class-split" tabindex="-1">NrrdTools 提取模块（God Class Split） <a class="header-anchor" href="#nrrdtools-提取模块-god-class-split" aria-label="Permalink to &quot;NrrdTools 提取模块（God Class Split）&quot;">​</a></h4><p>这三个模块由 <code>NrrdTools.initNrrdToolsModules()</code> 初始化，通过 <code>ToolContext</code> + <code>Pick&lt;ToolHost, ...&gt;</code> 类型与 NrrdTools 解耦：</p><table><thead><tr><th>模块</th><th>文件</th><th>行数</th><th>HostDeps 类型</th></tr></thead><tbody><tr><td><strong>LayerChannelManager</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/LayerChannelManager.ts">tools/LayerChannelManager.ts</a></td><td>211</td><td><code>LayerChannelHostDeps</code> (3 methods: <code>reloadMasksFromVolume</code>, <code>getVolumeForLayer</code>, <code>onChannelColorChanged</code>)</td></tr><tr><td><strong>SliceRenderPipeline</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/SliceRenderPipeline.ts">tools/SliceRenderPipeline.ts</a></td><td>453</td><td><code>SliceRenderHostDeps</code> (10 methods)</td></tr><tr><td><strong>DataLoader</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/DataLoader.ts">tools/DataLoader.ts</a></td><td>222</td><td><code>DataLoaderHostDeps</code> (7 methods)</td></tr></tbody></table><h4 id="drawtoolcore-管理的-tool-事件处理" tabindex="-1">DrawToolCore 管理的 Tool（事件处理） <a class="header-anchor" href="#drawtoolcore-管理的-tool-事件处理" aria-label="Permalink to &quot;DrawToolCore 管理的 Tool（事件处理）&quot;">​</a></h4><p>这些 Tool 由 <code>DrawToolCore.initTools()</code> 初始化，处理用户交互事件：</p><table><thead><tr><th>Tool</th><th>文件</th><th>HostDeps 类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>SphereTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/SphereTool.ts">tools/SphereTool.ts</a></td><td><code>SphereHostDeps</code></td><td>3D 球形标注工具，支持 4 种类型 (tumour/skin/ribcage/nipple)，包含点击放置 (<code>onSphereClick</code>) 和松开完成 (<code>onSpherePointerUp</code>)</td></tr><tr><td><strong>CrosshairTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/CrosshairTool.ts">tools/CrosshairTool.ts</a></td><td>—（无 callbacks）</td><td>十字准星位置标记、坐标转换、crosshair 渲染 (<code>renderCrosshair</code>)</td></tr><tr><td><strong>ContrastTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/ContrastTool.ts">tools/ContrastTool.ts</a></td><td><code>ContrastHostDeps</code></td><td>窗位/窗宽调节</td></tr><tr><td><strong>ZoomTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/ZoomTool.ts">tools/ZoomTool.ts</a></td><td><code>ZoomHostDeps</code></td><td>缩放/平移</td></tr><tr><td><strong>EraserTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/EraserTool.ts">tools/EraserTool.ts</a></td><td>—（无 callbacks）</td><td>橡皮擦</td></tr><tr><td><strong>PanTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/PanTool.ts">tools/PanTool.ts</a></td><td><code>PanHostDeps</code></td><td>右键拖拽平移画布</td></tr><tr><td><strong>DrawingTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/DrawingTool.ts">tools/DrawingTool.ts</a></td><td><code>DrawingHostDeps</code></td><td>铅笔/画笔/橡皮擦绘画逻辑，含笔刷 hover 追踪 (<code>createBrushTrackingHandler</code>) 和圆圈预览 (<code>renderBrushPreview</code>)</td></tr><tr><td><strong>ImageStoreHelper</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/ImageStoreHelper.ts">tools/ImageStoreHelper.ts</a></td><td><code>ImageStoreHostDeps</code></td><td>Canvas↔Volume 同步</td></tr><tr><td><strong>DragSliceTool</strong></td><td><a href="annotator-frontend/src/ts/Utils/segmentation/tools/DragSliceTool.ts">tools/DragSliceTool.ts</a></td><td><code>DragSliceHostDeps</code></td><td>拖拽切换切片</td></tr></tbody></table><p>Tool 初始化: <a href="annotator-frontend/src/ts/Utils/segmentation/DrawToolCore.ts">DrawToolCore.ts</a> <code>initTools()</code> 方法</p><h3 id="_7-2-imagestorehelper-关键工具" tabindex="-1">7.2 ImageStoreHelper（关键工具） <a class="header-anchor" href="#_7-2-imagestorehelper-关键工具" aria-label="Permalink to &quot;7.2 ImageStoreHelper（关键工具）&quot;">​</a></h3><p><strong><code>storeAllImages(index, layer)</code></strong> — <a href="./annotator-frontend/src/ts/Utils/segmentation/tools/ImageStoreHelper.ts.html#L116-L178">ImageStoreHelper.ts:116-178</a></p><p>Canvas → Volume 同步流程:</p><ol><li>将 layer canvas 绘制到 emptyCanvas [L124]</li><li>从 emptyCanvas 获取 ImageData [L127-132]</li><li>调用 <code>volume.setSliceLabelsFromImageData()</code> [L142-148] 写入 MaskVolume</li><li>提取切片通知后端 [L161]</li></ol><p><strong><code>filterDrawedImage(axis, sliceIndex)</code></strong> — <a href="./annotator-frontend/src/ts/Utils/segmentation/tools/ImageStoreHelper.ts.html#L85-L107">ImageStoreHelper.ts:85-107</a></p><p>Volume → Canvas 读取，调用 <code>volume.renderLabelSliceInto()</code>.</p><h3 id="_7-3-spheretool-球形标注工具" tabindex="-1">7.3 SphereTool（球形标注工具） <a class="header-anchor" href="#_7-3-spheretool-球形标注工具" aria-label="Permalink to &quot;7.3 SphereTool（球形标注工具）&quot;">​</a></h3><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/tools/SphereTool.ts">tools/SphereTool.ts</a></p><h4 id="类型与常量" tabindex="-1">类型与常量 <a class="header-anchor" href="#类型与常量" aria-label="Permalink to &quot;类型与常量&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SphereType</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;tumour&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;skin&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;nipple&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;ribcage&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">SPHERE_CHANNEL_MAP</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Record</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">SphereType</span><span style="color:#E1E4E8;">, { </span><span style="color:#FFAB70;">layer</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">; </span><span style="color:#FFAB70;">channel</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> }&gt;;</span></span>
<span class="line"><span style="color:#6A737D;">// SPHERE_COLORS 已删除 — 颜色改为从各 volume 的 colorMap 动态获取</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">SPHERE_LABELS</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Record</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">SphereType</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;default&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SphereType</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;tumour&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;skin&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;nipple&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;ribcage&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">SPHERE_CHANNEL_MAP</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Record</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">SphereType</span><span style="color:#24292E;">, { </span><span style="color:#E36209;">layer</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">; </span><span style="color:#E36209;">channel</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> }&gt;;</span></span>
<span class="line"><span style="color:#6A737D;">// SPHERE_COLORS 已删除 — 颜色改为从各 volume 的 colorMap 动态获取</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">SPHERE_LABELS</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Record</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">SphereType</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;default&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">&gt;;</span></span></code></pre></div><h4 id="辅助方法" tabindex="-1">辅助方法 <a class="header-anchor" href="#辅助方法" aria-label="Permalink to &quot;辅助方法&quot;">​</a></h4><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>getChannelForSphereType</code></td><td><code>(type: SphereType): number</code></td><td>获取 sphere 类型对应的 channel 号</td></tr><tr><td><code>getLayerForSphereType</code></td><td><code>(type: SphereType): string</code></td><td>获取 sphere 类型对应的 layer ID</td></tr><tr><td><code>getColorForSphereType</code></td><td><code>(type: SphereType): string</code></td><td>获取 sphere 类型对应的预览颜色</td></tr></tbody></table><h4 id="交互方法-从-drawtoolcore-提取" tabindex="-1">交互方法（从 DrawToolCore 提取） <a class="header-anchor" href="#交互方法-从-drawtoolcore-提取" aria-label="Permalink to &quot;交互方法（从 DrawToolCore 提取）&quot;">​</a></h4><table><thead><tr><th>方法</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>onSphereClick</code></td><td><code>(e: MouseEvent): void</code></td><td>左键点击：记录 origin、存储类型 origin、启用 crosshair、绘制预览圆。事件绑定（wheel/pointerup）留在 DrawToolCore</td></tr><tr><td><code>onSpherePointerUp</code></td><td><code>(): void</code></td><td>左键松开：写入所有 sphere 到 volume、刷新 overlay、触发 <code>onSphereChanged</code> + <code>onCalculatorPositionsChanged</code> 回调。事件清理留在 DrawToolCore</td></tr></tbody></table><h4 id="spherehostdeps-类型-pick-toolhost" tabindex="-1">SphereHostDeps 类型（Pick&lt;ToolHost, ...&gt;） <a class="header-anchor" href="#spherehostdeps-类型-pick-toolhost" aria-label="Permalink to &quot;SphereHostDeps 类型（Pick&lt;ToolHost, ...&gt;）&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// tools/ToolHost.ts</span></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SphereHostDeps</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Pick</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">ToolHost</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;setEmptyCanvasSize&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;drawImageOnEmptyImage&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;enableCrosshair&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;setUpSphereOrigins&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">&gt;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// tools/ToolHost.ts</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SphereHostDeps</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Pick</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">ToolHost</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;setEmptyCanvasSize&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;drawImageOnEmptyImage&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;enableCrosshair&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;setUpSphereOrigins&#39;</span></span>
<span class="line"><span style="color:#24292E;">&gt;;</span></span></code></pre></div><h4 id="使用边界" tabindex="-1">使用边界 <a class="header-anchor" href="#使用边界" aria-label="Permalink to &quot;使用边界&quot;">​</a></h4><p>Sphere 模式激活时：</p><ul><li>❌ <strong>Shift 键被禁用</strong> — 不能进入 draw 模式</li><li>✅ <strong>Crosshair 切换可用</strong> (S 键)</li><li>❌ <strong>clearPaint 不通知后端</strong></li><li>❌ <strong>Contrast 模式被阻止</strong></li></ul><h4 id="交互流程" tabindex="-1">交互流程 <a class="header-anchor" href="#交互流程" aria-label="Permalink to &quot;交互流程&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">左键按下 → 根据 activeSphereType 记录 origin → activeWheelMode = &#39;sphere&#39; → 绘制预览圆</span></span>
<span class="line"><span style="color:#e1e4e8;">           (tumour/skin/nipple/ribcage 各自存储 origin)</span></span>
<span class="line"><span style="color:#e1e4e8;">滚轮 (左键按住) → EventRouter wheel 派发到 handleSphereWheel → sphereRadius ±1 [1, 50] → 重绘</span></span>
<span class="line"><span style="color:#e1e4e8;">左键松开 → 写入所有已放置 sphere 到 volume → 触发 getSphere + getCalculateSpherePositions → activeWheelMode = &#39;zoom&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">左键按下 → 根据 activeSphereType 记录 origin → activeWheelMode = &#39;sphere&#39; → 绘制预览圆</span></span>
<span class="line"><span style="color:#24292e;">           (tumour/skin/nipple/ribcage 各自存储 origin)</span></span>
<span class="line"><span style="color:#24292e;">滚轮 (左键按住) → EventRouter wheel 派发到 handleSphereWheel → sphereRadius ±1 [1, 50] → 重绘</span></span>
<span class="line"><span style="color:#24292e;">左键松开 → 写入所有已放置 sphere 到 volume → 触发 getSphere + getCalculateSpherePositions → activeWheelMode = &#39;zoom&#39;</span></span></code></pre></div><h4 id="spheremaskvolume" tabindex="-1">SphereMaskVolume <a class="header-anchor" href="#spheremaskvolume" aria-label="Permalink to &quot;SphereMaskVolume&quot;">​</a></h4><p>独立 <code>MaskVolume</code>，存储 sphere 3D 数据，不污染 layer draw mask。</p><table><thead><tr><th>生命周期</th><th>位置</th><th>操作</th></tr></thead><tbody><tr><td>创建</td><td><code>NrrdTools.setAllSlices()</code></td><td><code>new MaskVolume(vw, vh, vd, 1)</code></td></tr><tr><td>清空</td><td><code>NrrdTools.reset()</code></td><td><code>sphereMaskVolume = null</code></td></tr><tr><td>存储</td><td><code>nrrd_states.sphereMaskVolume</code></td><td>—</td></tr></tbody></table><h3 id="_7-4-pantool-右键平移工具" tabindex="-1">7.4 PanTool（右键平移工具） <a class="header-anchor" href="#_7-4-pantool-右键平移工具" aria-label="Permalink to &quot;7.4 PanTool（右键平移工具）&quot;">​</a></h3><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/tools/PanTool.ts">tools/PanTool.ts</a> — 124 lines</p><p>从 <code>DrawToolCore.paintOnCanvas()</code> 提取（Phase 2, 2026-02-26）。处理所有右键拖拽平移逻辑。</p><h4 id="panhostdeps-类型-pick-toolhost" tabindex="-1">PanHostDeps 类型（Pick&lt;ToolHost, ...&gt;） <a class="header-anchor" href="#panhostdeps-类型-pick-toolhost" aria-label="Permalink to &quot;PanHostDeps 类型（Pick&lt;ToolHost, ...&gt;）&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// tools/ToolHost.ts</span></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PanHostDeps</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Pick</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">ToolHost</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;zoomActionAfterDrawSphere&#39;</span><span style="color:#E1E4E8;">&gt;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// tools/ToolHost.ts</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PanHostDeps</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Pick</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">ToolHost</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;zoomActionAfterDrawSphere&#39;</span><span style="color:#24292E;">&gt;;</span></span></code></pre></div><blockquote><p>⚠️ 原文档中的 <code>getPanelOffset</code> / <code>setPanelOffset</code> 回调<strong>已不存在</strong>。PanTool 现在直接通过 <code>canvas.offsetLeft</code> / <code>canvas.offsetTop</code> 读取偏移，无需外部回调。</p></blockquote><h4 id="关键属性与方法" tabindex="-1">关键属性与方法 <a class="header-anchor" href="#关键属性与方法" aria-label="Permalink to &quot;关键属性与方法&quot;">​</a></h4><table><thead><tr><th>成员</th><th>说明</th></tr></thead><tbody><tr><td><code>rightClicked: boolean</code></td><td>右键是否按下</td></tr><tr><td><code>panMoveInnerX/Y: number</code></td><td>平移拖拽起始位置偏移（clientX − canvas.offsetLeft）</td></tr><tr><td><code>isActive: boolean</code> (getter)</td><td>是否正在平移（用于 DrawToolCore re-entry guard）</td></tr><tr><td><code>onPointerDown(e)</code></td><td>右键按下：记录起始偏移，更改光标为 grab</td></tr><tr><td><code>onPointerMove(e)</code></td><td>拖拽中：计算并更新 canvas 位置</td></tr><tr><td><code>onPointerUp(e)</code></td><td>右键松开：清理状态，恢复光标</td></tr><tr><td><code>onPointerLeave()</code></td><td>canvas 离开：清理状态</td></tr></tbody></table><h4 id="与-drawtoolcore-集成" tabindex="-1">与 DrawToolCore 集成 <a class="header-anchor" href="#与-drawtoolcore-集成" aria-label="Permalink to &quot;与 DrawToolCore 集成&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// DrawToolCore.initTools()</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.panTool </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PanTool</span><span style="color:#E1E4E8;">(toolCtx, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">zoomActionAfterDrawSphere</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">zoomActionAfterDrawSphere</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// handleOnDrawingMouseDown — right-click branch</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.panTool.</span><span style="color:#B392F0;">onPointerDown</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#6A737D;">// pointerup permanently routed by EventRouter</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// handleOnDrawingMouseUp — right-click branch</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.panTool.</span><span style="color:#B392F0;">onPointerUp</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// handlePointerLeave (registered once via EventRouter)</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.panTool.</span><span style="color:#B392F0;">onPointerLeave</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// DrawToolCore.initTools()</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.panTool </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PanTool</span><span style="color:#24292E;">(toolCtx, {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">zoomActionAfterDrawSphere</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">zoomActionAfterDrawSphere</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// handleOnDrawingMouseDown — right-click branch</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.panTool.</span><span style="color:#6F42C1;">onPointerDown</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#6A737D;">// pointerup permanently routed by EventRouter</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// handleOnDrawingMouseUp — right-click branch</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.panTool.</span><span style="color:#6F42C1;">onPointerUp</span><span style="color:#24292E;">(e);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// handlePointerLeave (registered once via EventRouter)</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.panTool.</span><span style="color:#6F42C1;">onPointerLeave</span><span style="color:#24292E;">();</span></span></code></pre></div><hr><h3 id="_7-5-drawingtool-绘画工具" tabindex="-1">7.5 DrawingTool（绘画工具） <a class="header-anchor" href="#_7-5-drawingtool-绘画工具" aria-label="Permalink to &quot;7.5 DrawingTool（绘画工具）&quot;">​</a></h3><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/tools/DrawingTool.ts">tools/DrawingTool.ts</a> — 284 lines</p><p>从 <code>DrawToolCore.paintOnCanvas()</code> 提取（Phase 3, 2026-02-26）。处理铅笔、画笔、橡皮擦的所有绘画逻辑，包含 Undo 快照。</p><h4 id="drawinghostdeps-类型-pick-toolhost" tabindex="-1">DrawingHostDeps 类型（Pick&lt;ToolHost, ...&gt;） <a class="header-anchor" href="#drawinghostdeps-类型-pick-toolhost" aria-label="Permalink to &quot;DrawingHostDeps 类型（Pick&lt;ToolHost, ...&gt;）&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// tools/ToolHost.ts</span></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DrawingHostDeps</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Pick</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">ToolHost</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;setCurrentLayer&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;compositeAllLayers&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;syncLayerSliceData&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;filterDrawedImage&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;getVolumeForLayer&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;pushUndoDelta&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;getEraserUrls&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">&gt;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// tools/ToolHost.ts</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DrawingHostDeps</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Pick</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">ToolHost</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;setCurrentLayer&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;compositeAllLayers&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;syncLayerSliceData&#39;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;filterDrawedImage&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;getVolumeForLayer&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;pushUndoDelta&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;getEraserUrls&#39;</span></span>
<span class="line"><span style="color:#24292E;">&gt;;</span></span></code></pre></div><h4 id="关键属性与方法-1" tabindex="-1">关键属性与方法 <a class="header-anchor" href="#关键属性与方法-1" aria-label="Permalink to &quot;关键属性与方法&quot;">​</a></h4><table><thead><tr><th>成员</th><th>说明</th></tr></thead><tbody><tr><td><code>leftClicked: boolean</code></td><td>左键是否按下</td></tr><tr><td><code>isPainting: boolean</code></td><td>是否正在绘画（mousedown 到 mouseup 期间）</td></tr><tr><td><code>drawingLines: ICommXY[]</code></td><td>铅笔模式路径点集合</td></tr><tr><td><code>clearArcFn</code></td><td>当前帧的橡皮擦函数（由 <code>reset()</code> 注入）</td></tr><tr><td><code>preDrawSlice/Axis/SliceIndex</code></td><td>mousedown 时的 undo 快照数据</td></tr><tr><td><code>isActive: boolean</code> (getter)</td><td>暴露 <code>leftClicked</code>，用于 DrawToolCore re-entry guard</td></tr><tr><td><code>painting: boolean</code> (getter)</td><td>暴露 <code>isPainting</code>，用于 mouseUp 条件判断</td></tr><tr><td><code>reset(clearArcFn)</code></td><td>每次 <code>paintOnCanvas()</code> 调用时重置状态并注入新橡皮擦函数</td></tr><tr><td><code>onPointerDown(e)</code></td><td>左键按下：设置光标、初始化路径、capturePreDrawSnapshot</td></tr><tr><td><code>onPointerMove(e)</code></td><td>移动：橡皮擦分支用 clearArcFn，绘画分支积累路径并调用 paintOnCanvasLayer</td></tr><tr><td><code>onPointerUp(e)</code></td><td>左键松开：铅笔 fill/画笔 closePath、syncLayerSliceData、pushUndoDelta</td></tr><tr><td><code>onPointerLeave()</code></td><td>canvas 离开：重置状态，<strong>返回 <code>boolean</code></strong> 表示是否有未完成绘画</td></tr><tr><td><code>createBrushTrackingHandler()</code></td><td>返回 mouseover/mouseout/mousemove handler，追踪 mouseOverX/Y 和 mouseOver 状态</td></tr><tr><td><code>renderBrushPreview(ctx, w, h)</code></td><td>在 draw 模式渲染笔刷圆圈预览（start() render loop 调用）</td></tr></tbody></table><h4 id="onpointerleave-返回值约定" tabindex="-1">onPointerLeave 返回值约定 <a class="header-anchor" href="#onpointerleave-返回值约定" aria-label="Permalink to &quot;onPointerLeave 返回值约定&quot;">​</a></h4><p><code>onPointerLeave()</code> 返回 <code>true</code> 表示用户正在绘画时离开（即 DrawToolCore 需要恢复 wheel 状态）：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// DrawToolCore.handlePointerLeave() — 通过 EventRouter 永久路由</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">wasDrawing</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.drawingTool.</span><span style="color:#B392F0;">onPointerLeave</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (wasDrawing) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 恢复 zoom wheel 模式（不再需要手动 removeEventListener）</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.activeWheelMode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;zoom&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.panTool.</span><span style="color:#B392F0;">onPointerLeave</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// DrawToolCore.handlePointerLeave() — 通过 EventRouter 永久路由</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">wasDrawing</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.drawingTool.</span><span style="color:#6F42C1;">onPointerLeave</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (wasDrawing) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 恢复 zoom wheel 模式（不再需要手动 removeEventListener）</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.activeWheelMode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;zoom&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.panTool.</span><span style="color:#6F42C1;">onPointerLeave</span><span style="color:#24292E;">();</span></span></code></pre></div><h4 id="与-drawtoolcore-集成-1" tabindex="-1">与 DrawToolCore 集成 <a class="header-anchor" href="#与-drawtoolcore-集成-1" aria-label="Permalink to &quot;与 DrawToolCore 集成&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// DrawToolCore.initTools()</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.drawingTool </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DrawingTool</span><span style="color:#E1E4E8;">(toolCtx, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">setCurrentLayer</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">setCurrentLayer</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">compositeAllLayers</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.renderer.</span><span style="color:#B392F0;">compositeAllLayers</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">syncLayerSliceData</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">index</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">layer</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">syncLayerSliceData</span><span style="color:#E1E4E8;">(index, layer),</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">filterDrawedImage</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">axis</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">index</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.renderer.</span><span style="color:#B392F0;">filterDrawedImage</span><span style="color:#E1E4E8;">(axis, index),</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getVolumeForLayer</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">layer</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.renderer.</span><span style="color:#B392F0;">getVolumeForLayer</span><span style="color:#E1E4E8;">(layer),</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">pushUndoDelta</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">delta</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.undoManager.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(delta),</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getEraserUrls</span><span style="color:#E1E4E8;">: () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.eraserUrls,</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// paintOnCanvas() — reset each call</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.drawingTool.</span><span style="color:#B392F0;">reset</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">useEraser</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Re-entry guard</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.drawingTool.isActive </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.panTool.isActive) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// DrawToolCore.initTools()</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.drawingTool </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DrawingTool</span><span style="color:#24292E;">(toolCtx, {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">setCurrentLayer</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">setCurrentLayer</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">compositeAllLayers</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.renderer.</span><span style="color:#6F42C1;">compositeAllLayers</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">syncLayerSliceData</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">index</span><span style="color:#24292E;">, </span><span style="color:#E36209;">layer</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">syncLayerSliceData</span><span style="color:#24292E;">(index, layer),</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">filterDrawedImage</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">axis</span><span style="color:#24292E;">, </span><span style="color:#E36209;">index</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.renderer.</span><span style="color:#6F42C1;">filterDrawedImage</span><span style="color:#24292E;">(axis, index),</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getVolumeForLayer</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">layer</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.renderer.</span><span style="color:#6F42C1;">getVolumeForLayer</span><span style="color:#24292E;">(layer),</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">pushUndoDelta</span><span style="color:#24292E;">: (</span><span style="color:#E36209;">delta</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.undoManager.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(delta),</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getEraserUrls</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.eraserUrls,</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// paintOnCanvas() — reset each call</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.drawingTool.</span><span style="color:#6F42C1;">reset</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">useEraser</span><span style="color:#24292E;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Re-entry guard</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.drawingTool.isActive </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.panTool.isActive) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span></code></pre></div><h4 id="undo-快照机制" tabindex="-1">Undo 快照机制 <a class="header-anchor" href="#undo-快照机制" aria-label="Permalink to &quot;Undo 快照机制&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">mousedown → capturePreDrawSnapshot()</span></span>
<span class="line"><span style="color:#e1e4e8;">  → callbacks.getVolumeForLayer(layer).getSliceUint8(sliceIndex, axis)</span></span>
<span class="line"><span style="color:#e1e4e8;">  → 保存到 preDrawSlice / preDrawAxis / preDrawSliceIndex</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">mouseup → pushUndoDelta()</span></span>
<span class="line"><span style="color:#e1e4e8;">  → callbacks.getVolumeForLayer(layer).getSliceUint8(sliceIndex, axis)  ← 操作后</span></span>
<span class="line"><span style="color:#e1e4e8;">  → callbacks.pushUndoDelta({ layerId, axis, sliceIndex, oldSlice: preDrawSlice, newSlice })</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">mousedown → capturePreDrawSnapshot()</span></span>
<span class="line"><span style="color:#24292e;">  → callbacks.getVolumeForLayer(layer).getSliceUint8(sliceIndex, axis)</span></span>
<span class="line"><span style="color:#24292e;">  → 保存到 preDrawSlice / preDrawAxis / preDrawSliceIndex</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">mouseup → pushUndoDelta()</span></span>
<span class="line"><span style="color:#24292e;">  → callbacks.getVolumeForLayer(layer).getSliceUint8(sliceIndex, axis)  ← 操作后</span></span>
<span class="line"><span style="color:#24292e;">  → callbacks.pushUndoDelta({ layerId, axis, sliceIndex, oldSlice: preDrawSlice, newSlice })</span></span></code></pre></div><hr><h2 id="_8-eventrouter-事件路由" tabindex="-1">8. EventRouter（事件路由） <a class="header-anchor" href="#_8-eventrouter-事件路由" aria-label="Permalink to &quot;8. EventRouter（事件路由）&quot;">​</a></h2><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/eventRouter/EventRouter.ts">eventRouter/EventRouter.ts</a></p><h3 id="_8-1-交互模式" tabindex="-1">8.1 交互模式 <a class="header-anchor" href="#_8-1-交互模式" aria-label="Permalink to &quot;8.1 交互模式&quot;">​</a></h3><table><thead><tr><th>Mode</th><th>触发条件</th><th>说明</th></tr></thead><tbody><tr><td><code>idle</code></td><td>默认</td><td>无交互</td></tr><tr><td><code>draw</code></td><td>Shift 按住</td><td>绘画模式</td></tr><tr><td><code>drag</code></td><td>垂直拖拽</td><td>切片导航</td></tr><tr><td><code>contrast</code></td><td>Ctrl/Meta 按住</td><td>窗位/窗宽调节</td></tr><tr><td><code>crosshair</code></td><td>S 键</td><td>十字准星</td></tr></tbody></table><h3 id="_8-2-事件永久路由-event-lifecycle-refactor" tabindex="-1">8.2 事件永久路由（Event Lifecycle Refactor） <a class="header-anchor" href="#_8-2-事件永久路由-event-lifecycle-refactor" aria-label="Permalink to &quot;8.2 事件永久路由（Event Lifecycle Refactor）&quot;">​</a></h3><p>EventRouter 在 <code>bindAll()</code> 时永久绑定所有 pointer/keyboard/wheel 事件到 drawingCanvas。DrawToolCore 通过 <code>set*Handler()</code> 注册处理器，不再手动 <code>addEventListener</code>/<code>removeEventListener</code>。</p><h4 id="注册的处理器" tabindex="-1">注册的处理器 <a class="header-anchor" href="#注册的处理器" aria-label="Permalink to &quot;注册的处理器&quot;">​</a></h4><table><thead><tr><th>方法</th><th>Handler 内容</th><th>守卫条件</th></tr></thead><tbody><tr><td><code>setPointerDownHandler</code></td><td>转发到 <code>handleOnDrawingMouseDown</code></td><td>无（每次 pointerdown 都转发）</td></tr><tr><td><code>setPointerMoveHandler</code></td><td>转发到 <code>handleOnDrawingMouseMove</code></td><td><code>drawingTool.isActive || panTool.isActive</code>（仅活跃交互时转发）</td></tr><tr><td><code>setPointerUpHandler</code></td><td>转发到 <code>handleOnDrawingMouseUp</code></td><td><code>drawingTool.isActive || drawingTool.painting || panTool.isActive || sphere模式</code></td></tr><tr><td><code>setPointerLeaveHandler</code></td><td>调用 <code>handlePointerLeave()</code></td><td>无</td></tr><tr><td><code>setWheelHandler</code></td><td>根据 <code>activeWheelMode</code> 派发</td><td>无</td></tr></tbody></table><blockquote><p>⚠️ <strong>守卫条件是必须的</strong>：<code>drawingTool.onPointerMove()</code> 无条件设置 <code>isDrawing=true</code>（DrawingTool L108），如果不加守卫，空闲时鼠标移动会导致 Brush 预览和 Crosshair 无法渲染。</p></blockquote><h4 id="wheel-派发器-activewheelmode" tabindex="-1">Wheel 派发器（<code>activeWheelMode</code>） <a class="header-anchor" href="#wheel-派发器-activewheelmode" aria-label="Permalink to &quot;Wheel 派发器（\`activeWheelMode\`）&quot;">​</a></h4><p>DrawToolCore 新增 <code>activeWheelMode: &#39;zoom&#39; | &#39;sphere&#39; | &#39;none&#39;</code> 字段，替代原来的手动 wheel add/remove：</p><table><thead><tr><th>Mode</th><th>触发场景</th><th>派发目标</th></tr></thead><tbody><tr><td><code>&#39;zoom&#39;</code></td><td>默认 / mouseUp 恢复</td><td><code>handleMouseZoomSliceWheel</code></td></tr><tr><td><code>&#39;sphere&#39;</code></td><td><code>handleSphereClick</code> 设置</td><td><code>handleSphereWheel</code></td></tr><tr><td><code>&#39;none&#39;</code></td><td>draw 模式 mouseDown 设置</td><td>无操作（抑制滚轮）</td></tr></tbody></table><h3 id="_8-3-默认键盘设置" tabindex="-1">8.3 默认键盘设置 <a class="header-anchor" href="#_8-3-默认键盘设置" aria-label="Permalink to &quot;8.3 默认键盘设置&quot;">​</a></h3><p>定义: <a href="annotator-frontend/src/ts/Utils/segmentation/CanvasState.ts">CanvasState.ts</a> <code>keyboardSettings</code> 字段</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">IKeyBoardSettings </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  draw: </span><span style="color:#9ECBFF;">&quot;Shift&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  undo: </span><span style="color:#9ECBFF;">&quot;z&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  redo: </span><span style="color:#9ECBFF;">&quot;y&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  contrast: [</span><span style="color:#9ECBFF;">&quot;Control&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;Meta&quot;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">  crosshair: </span><span style="color:#9ECBFF;">&quot;s&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  sphere: </span><span style="color:#9ECBFF;">&quot;q&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  mouseWheel: </span><span style="color:#9ECBFF;">&quot;Scroll:Zoom&quot;</span><span style="color:#E1E4E8;">,   </span><span style="color:#6A737D;">// 或 &quot;Scroll:Slice&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">IKeyBoardSettings </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  draw: </span><span style="color:#032F62;">&quot;Shift&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  undo: </span><span style="color:#032F62;">&quot;z&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  redo: </span><span style="color:#032F62;">&quot;y&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  contrast: [</span><span style="color:#032F62;">&quot;Control&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;Meta&quot;</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">  crosshair: </span><span style="color:#032F62;">&quot;s&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  sphere: </span><span style="color:#032F62;">&quot;q&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  mouseWheel: </span><span style="color:#032F62;">&quot;Scroll:Zoom&quot;</span><span style="color:#24292E;">,   </span><span style="color:#6A737D;">// 或 &quot;Scroll:Slice&quot;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><hr><h2 id="_9-undo-redo-系统" tabindex="-1">9. Undo/Redo 系统 <a class="header-anchor" href="#_9-undo-redo-系统" aria-label="Permalink to &quot;9. Undo/Redo 系统&quot;">​</a></h2><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/core/UndoManager.ts">core/UndoManager.ts</a></p><h3 id="delta-结构" tabindex="-1">Delta 结构 <a class="header-anchor" href="#delta-结构" aria-label="Permalink to &quot;Delta 结构&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MaskDelta</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">layerId</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">axis</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;x&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;y&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;z&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">sliceIndex</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">oldSlice</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Uint8Array</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">// 操作前的切片数据</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">newSlice</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Uint8Array</span><span style="color:#E1E4E8;">;   </span><span style="color:#6A737D;">// 操作后的切片数据</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MaskDelta</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">layerId</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">axis</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;x&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;y&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;z&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">sliceIndex</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">oldSlice</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Uint8Array</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">// 操作前的切片数据</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">newSlice</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Uint8Array</span><span style="color:#24292E;">;   </span><span style="color:#6A737D;">// 操作后的切片数据</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>每个 Layer 独立的 undo/redo 栈</li><li>MAX_STACK_SIZE = 50</li></ul><h3 id="undo-流程" tabindex="-1">Undo 流程 <a class="header-anchor" href="#undo-流程" aria-label="Permalink to &quot;Undo 流程&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">DrawToolCore.undoLastPainting()</span></span>
<span class="line"><span style="color:#e1e4e8;">  → UndoManager.undo() → MaskDelta</span></span>
<span class="line"><span style="color:#e1e4e8;">  → vol.setSliceUint8(delta.sliceIndex, delta.oldSlice, delta.axis)</span></span>
<span class="line"><span style="color:#e1e4e8;">  → applyUndoRedoToCanvas(layerId)</span></span>
<span class="line"><span style="color:#e1e4e8;">    → getOrCreateSliceBuffer(axis)</span></span>
<span class="line"><span style="color:#e1e4e8;">    → renderSliceToCanvas(...)</span></span>
<span class="line"><span style="color:#e1e4e8;">    → compositeAllLayers()</span></span>
<span class="line"><span style="color:#e1e4e8;">  → annotationCallbacks.onMaskChanged(sliceData, ...) → 通知后端</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">DrawToolCore.undoLastPainting()</span></span>
<span class="line"><span style="color:#24292e;">  → UndoManager.undo() → MaskDelta</span></span>
<span class="line"><span style="color:#24292e;">  → vol.setSliceUint8(delta.sliceIndex, delta.oldSlice, delta.axis)</span></span>
<span class="line"><span style="color:#24292e;">  → applyUndoRedoToCanvas(layerId)</span></span>
<span class="line"><span style="color:#24292e;">    → getOrCreateSliceBuffer(axis)</span></span>
<span class="line"><span style="color:#24292e;">    → renderSliceToCanvas(...)</span></span>
<span class="line"><span style="color:#24292e;">    → compositeAllLayers()</span></span>
<span class="line"><span style="color:#24292e;">  → annotationCallbacks.onMaskChanged(sliceData, ...) → 通知后端</span></span></code></pre></div><hr><h2 id="_10-dragoperator" tabindex="-1">10. DragOperator <a class="header-anchor" href="#_10-dragoperator" aria-label="Permalink to &quot;10. DragOperator&quot;">​</a></h2><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/DragOperator.ts">DragOperator.ts</a></p><p>负责拖拽交互（切片导航）。</p><blockquote><p>⚠️ <strong>Event Lifecycle Refactor 变更</strong>: DragOperator 不再手动管理 wheel 事件监听器。原先在 <code>handleOnDragMouseDown</code> 中 <code>removeEventListener(&quot;wheel&quot;, ...)</code> 和在 <code>handleOnDragMouseUp</code> 中 <code>addEventListener(&quot;wheel&quot;, ...)</code> 的操作已删除，wheel 现在完全由 EventRouter 的 <code>activeWheelMode</code> 派发器管理。</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>drag(opts?)</code></td><td>启用拖拽模式</td></tr><tr><td><code>configDragMode()</code></td><td>绑定拖拽监听器</td></tr><tr><td><code>removeDragMode()</code></td><td>移除拖拽监听器</td></tr><tr><td><code>updateIndex(move)</code></td><td>委托给 DragSliceTool</td></tr><tr><td><code>setEventRouter(eventRouter)</code></td><td>订阅模式变化</td></tr></tbody></table><hr><h2 id="_11-channel-颜色定义" tabindex="-1">11. Channel 颜色定义 <a class="header-anchor" href="#_11-channel-颜色定义" aria-label="Permalink to &quot;11. Channel 颜色定义&quot;">​</a></h2><p><strong>文件</strong>: <a href="annotator-frontend/src/ts/Utils/segmentation/core/types.ts">core/types.ts</a></p><h3 id="_11-1-默认颜色-全局常量" tabindex="-1">11.1 默认颜色（全局常量） <a class="header-anchor" href="#_11-1-默认颜色-全局常量" aria-label="Permalink to &quot;11.1 默认颜色（全局常量）&quot;">​</a></h3><table><thead><tr><th>Channel</th><th>颜色</th><th>Hex</th><th>RGBA</th></tr></thead><tbody><tr><td>0</td><td>透明</td><td><code>#000000</code></td><td><code>(0,0,0,0)</code></td></tr><tr><td>1</td><td>祖母绿 (Primary/Tumor)</td><td><code>#10b981</code></td><td><code>(16,185,129,255)</code></td></tr><tr><td>2</td><td>玫瑰红 (Secondary/Edema)</td><td><code>#f43f5e</code></td><td><code>(244,63,94,255)</code></td></tr><tr><td>3</td><td>蓝色 (Tertiary/Necrosis)</td><td><code>#3b82f6</code></td><td><code>(59,130,246,255)</code></td></tr><tr><td>4</td><td>琥珀黄 (Enhancement)</td><td><code>#fbbf24</code></td><td><code>(251,191,36,255)</code></td></tr><tr><td>5</td><td>紫红 Fuchsia (Vessel/Boundary)</td><td><code>#d946ef</code></td><td><code>(217,70,239,255)</code></td></tr><tr><td>6</td><td>青绿 Cyan (Additional)</td><td><code>#06b6d4</code></td><td><code>(6,182,212,255)</code></td></tr><tr><td>7</td><td>橙色 (Auxiliary)</td><td><code>#f97316</code></td><td><code>(249,115,22,255)</code></td></tr><tr><td>8</td><td>紫色 Violet (Extended)</td><td><code>#8b5cf6</code></td><td><code>(139,92,246,255)</code></td></tr></tbody></table><p>定义位置:</p><ul><li>RGBA: <code>MASK_CHANNEL_COLORS</code></li><li>CSS: <code>MASK_CHANNEL_CSS_COLORS</code></li><li>Hex: <code>CHANNEL_HEX_COLORS</code></li></ul><h3 id="_11-2-颜色转换工具函数-phase-b-新增" tabindex="-1">11.2 颜色转换工具函数（Phase B 新增） <a class="header-anchor" href="#_11-2-颜色转换工具函数-phase-b-新增" aria-label="Permalink to &quot;11.2 颜色转换工具函数（Phase B 新增）&quot;">​</a></h3><table><thead><tr><th>函数</th><th>签名</th><th>说明</th></tr></thead><tbody><tr><td><code>rgbaToHex</code></td><td><code>(color: RGBAColor) → string</code></td><td>转 Hex 字符串，如 <code>#ff8000</code></td></tr><tr><td><code>rgbaToCss</code></td><td><code>(color: RGBAColor) → string</code></td><td>转 CSS rgba() 字符串，如 <code>rgba(255,128,0,1.00)</code></td></tr></tbody></table><h3 id="_11-3-per-layer-自定义颜色-phase-b" tabindex="-1">11.3 Per-Layer 自定义颜色（Phase B） <a class="header-anchor" href="#_11-3-per-layer-自定义颜色-phase-b" aria-label="Permalink to &quot;11.3 Per-Layer 自定义颜色（Phase B）&quot;">​</a></h3><p>每个 <code>MaskVolume</code> 实例拥有独立的 <code>colorMap: ChannelColorMap</code>，在构造时从 <code>MASK_CHANNEL_COLORS</code> 深拷贝。通过 <code>NrrdTools.setChannelColor(layerId, channel, color)</code> 修改某个 layer 的颜色不会影响其他 layer。</p><p><strong>颜色流转路径</strong>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">volume.colorMap[channel]</span></span>
<span class="line"><span style="color:#e1e4e8;">  ↓ renderLabelSliceInto()     → Canvas 渲染使用 colorMap</span></span>
<span class="line"><span style="color:#e1e4e8;">  ↓ buildRgbToChannelMap()     → Canvas→Volume 写回使用 colorMap</span></span>
<span class="line"><span style="color:#e1e4e8;">  ↓ EraserTool.getChannelColor → 橡皮擦颜色匹配使用 colorMap</span></span>
<span class="line"><span style="color:#e1e4e8;">  ↓ syncBrushColor()           → 画笔颜色从 colorMap 获取</span></span>
<span class="line"><span style="color:#e1e4e8;">  ↓ getChannelCssColor()       → Vue UI 从 colorMap 获取显示颜色</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">volume.colorMap[channel]</span></span>
<span class="line"><span style="color:#24292e;">  ↓ renderLabelSliceInto()     → Canvas 渲染使用 colorMap</span></span>
<span class="line"><span style="color:#24292e;">  ↓ buildRgbToChannelMap()     → Canvas→Volume 写回使用 colorMap</span></span>
<span class="line"><span style="color:#24292e;">  ↓ EraserTool.getChannelColor → 橡皮擦颜色匹配使用 colorMap</span></span>
<span class="line"><span style="color:#24292e;">  ↓ syncBrushColor()           → 画笔颜色从 colorMap 获取</span></span>
<span class="line"><span style="color:#24292e;">  ↓ getChannelCssColor()       → Vue UI 从 colorMap 获取显示颜色</span></span></code></pre></div>`,293),t=[l];function p(r,c,d,i,y,E){return a(),n("div",null,t)}const u=s(o,[["render",p]]);export{g as __pageData,u as default};
